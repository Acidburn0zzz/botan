<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.tls.channel</title>
        </head><body>
        <h1>botan.tls.channel</h1>
        <!-- Generated by Ddoc from source/botan/tls/channel.d -->
TLS Channel
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="TLSChannel"></a>abstract class <u>TLSChannel</u>;
</big></dt>
<dd>Generic interface for TLS endpoint<br><br>

<dl><dt><big><a name="TLSChannel.receivedData"></a>size_t <u>receivedData</u>(const(ubyte)* <i>input</i>, size_t <i>input_size</i>);
</big></dt>
<dd>Inject TLS traffic received from counterparty
<br><br>
<b>Returns:</b><br>
a hint as the how many more bytes we need to process the
            current record (this may be 0 if on a record boundary)<br><br>

</dd>
<dt><big><a name="TLSChannel.receivedData.2"></a>size_t <u>receivedData</u>(ref const Vector!ubyte <i>buf</i>);
</big></dt>
<dd>Inject TLS traffic received from counterparty
<br><br>
<b>Returns:</b><br>
a hint as the how many more bytes we need to process the
            current record (this may be 0 if on a record boundary)<br><br>

</dd>
<dt><big><a name="TLSChannel.send"></a>void <u>send</u>(const(ubyte)* <i>buf</i>, size_t <i>buf_size</i>);
</big></dt>
<dd>Inject plaintext intended for counterparty<br><br>

</dd>
<dt><big><a name="TLSChannel.send.2"></a>void <u>send</u>(in string <i>str</i>);
</big></dt>
<dd>Inject plaintext intended for counterparty<br><br>

</dd>
<dt><big><a name="TLSChannel.send.3"></a>void <u>send</u>(Alloc)(ref const Vector!(char, Alloc) <i>val</i>);
</big></dt>
<dd>Inject plaintext intended for counterparty<br><br>

</dd>
<dt><big><a name="TLSChannel.sendAlert"></a>void <u>sendAlert</u>(in TLSAlert <i>alert</i>);
</big></dt>
<dd>Send a TLS <i>alert</i> message. If the <i>alert</i> is fatal, the internal
 state (keys, etc) will be reset.
<br><br>
<b>Params:</b><br>
<table><tr><td>TLSAlert <i>alert</i></td>
<td>the TLSAlert to send</td></tr>
</table><br>

</dd>
<dt><big><a name="TLSChannel.sendWarningAlert"></a>void <u>sendWarningAlert</u>(TLSAlertType <i>type</i>);
</big></dt>
<dd>Send a warning alert<br><br>

</dd>
<dt><big><a name="TLSChannel.sendFatalAlert"></a>void <u>sendFatalAlert</u>(TLSAlertType <i>type</i>);
</big></dt>
<dd>Send a fatal alert<br><br>

</dd>
<dt><big><a name="TLSChannel.close"></a>void <u>close</u>();
</big></dt>
<dd>Send a <u>close</u> notification alert<br><br>

</dd>
<dt><big><a name="TLSChannel.isActive"></a>const bool <u>isActive</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff the connection is active for sending application data<br><br>

</dd>
<dt><big><a name="TLSChannel.isClosed"></a>const bool <u>isClosed</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff the connection has been definitely closed<br><br>

</dd>
<dt><big><a name="TLSChannel.renegotiate"></a>void <u>renegotiate</u>(bool <i>force_full_renegotiation</i> = false);
</big></dt>
<dd>Attempt to <u>renegotiate</u> the session
<br><br>
<b>Params:</b><br>
<table><tr><td>bool <i>force_full_renegotiation</i></td>
<td>if <b>true</b>, require a full renegotiation,
                                            otherwise allow session resumption</td></tr>
</table><br>

</dd>
<dt><big><a name="TLSChannel.peerSupportsHeartbeats"></a>const bool <u>peerSupportsHeartbeats</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff the peer supports heartbeat messages<br><br>

</dd>
<dt><big><a name="TLSChannel.heartbeatSendingAllowed"></a>const bool <u>heartbeatSendingAllowed</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff we are allowed to send heartbeat messages<br><br>

</dd>
<dt><big><a name="TLSChannel.heartbeat"></a>void <u>heartbeat</u>(const(ubyte)* <i>payload</i>, size_t <i>payload_size</i>);
</big></dt>
<dd>Attempt to send a <u>heartbeat</u> message (if negotiated with counterparty)
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>payload</i></td>
<td>will be echoed back</td></tr>
<tr><td>size_t <i>payload_size</i></td>
<td>size of <i>payload</i> in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="TLSChannel.heartbeat.2"></a>void <u>heartbeat</u>();
</big></dt>
<dd>Attempt to send a <u>heartbeat</u> message (if negotiated with counterparty)<br><br>

</dd>
<dt><big><a name="TLSChannel.peerCertChain"></a>const Vector!X509Certificate <u>peerCertChain</u>();
</big></dt>
<dd><b>Returns:</b><br>
certificate chain of the peer (may be empty)<br><br>

</dd>
<dt><big><a name="TLSChannel.keyMaterialExport"></a>const const(SymmetricKey) <u>keyMaterialExport</u>(in string <i>label</i>, in string <i>context</i>, size_t <i>length</i>);
</big></dt>
<dd>Key material export (RFC 5705)
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>label</i></td>
<td>a disambiguating <i>label</i> string</td></tr>
<tr><td>string <i>context</i></td>
<td>a per-association <i>context</i> value</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the desired key in bytes</td></tr>
</table><br>
<b>Returns:</b><br>
key of <i>length</i> bytes<br><br>

</dd>
<dt><big><a name="TLSChannel.secureRenegotiationSupported"></a>protected const bool <u>secureRenegotiationSupported</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> iff the counterparty supports the secure
 renegotiation extensions.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2011,2012 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
