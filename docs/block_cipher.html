<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.block.block_cipher</title>
        </head><body>
        <h1>botan.block.block_cipher</h1>
        <!-- Generated by Ddoc from source/botan/block/block_cipher.d -->
Block Cipher Base Class
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="BlockCipher"></a>interface <u>BlockCipher</u>: <u>botan.algo_base.sym_algo.SymmetricAlgorithm</u>;
</big></dt>
<dd>This class represents a block cipher object.<br><br>

<dl><dt><big><a name="BlockCipher.blockSize"></a>abstract const size_t <u>blockSize</u>();
</big></dt>
<dd><b>Returns:</b><br>
block size of this algorithm<br><br>

</dd>
<dt><big><a name="BlockCipher.parallelism"></a>abstract const @property size_t <u>parallelism</u>();
</big></dt>
<dd><b>Returns:</b><br>
native <u>parallelism</u> of this cipher in blocks<br><br>

</dd>
<dt><big><a name="BlockCipher.parallelBytes"></a>final const size_t <u>parallelBytes</u>();
</big></dt>
<dd><b>Returns:</b><br>
prefererred parallelism of this cipher in bytes<br><br>

</dd>
<dt><big><a name="BlockCipher.encrypt"></a>final void <u>encrypt</u>(const(ubyte)* <i>input</i>, ubyte* <i>output</i>);
</big></dt>
<dd>Encrypt a block.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>The plaintext block to be encrypted as a ubyte array.</td></tr>
<tr><td>ubyte* <i>output</i></td>
<td>The ubyte array designated to hold the encrypted block.</td></tr>
</table><br>
<b>Notes:</b><br>
Both arguments must be of length blockSize().<br><br>

</dd>
<dt><big><a name="BlockCipher.decrypt"></a>final void <u>decrypt</u>(const(ubyte)* <i>input</i>, ubyte* <i>output</i>);
</big></dt>
<dd>Decrypt a block.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>The ciphertext block to be decypted as a ubyte array.</td></tr>
<tr><td>ubyte* <i>output</i></td>
<td>The ubyte array designated to hold the decrypted block.</td></tr>
</table><br>
<b>Notes:</b><br>
Both parameters must be of length blockSize().<br><br>

</dd>
<dt><big><a name="BlockCipher.encrypt.2"></a>final void <u>encrypt</u>(ubyte* <i>block</i>);
</big></dt>
<dd>Encrypt a <i>block</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>block</i></td>
<td>the plaintext <i>block</i> to be encrypted</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length blockSize(). Will hold the result when the function
 has finished.<br><br>

</dd>
<dt><big><a name="BlockCipher.decrypt.2"></a>final void <u>decrypt</u>(ubyte* <i>block</i>);
</big></dt>
<dd>Decrypt a <i>block</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>block</i></td>
<td>the ciphertext <i>block</i> to be decrypted</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length blockSize(). Will hold the result when the function
 has finished.<br><br>

</dd>
<dt><big><a name="BlockCipher.encrypt.3"></a>final void <u>encrypt</u>(ref ubyte[] <i>block</i>);
</big></dt>
<dd>Encrypt a <i>block</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>block</i></td>
<td>the plaintext <i>block</i> to be encrypted</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length blockSize(). Will hold the result when the function
 has finished.<br><br>

</dd>
<dt><big><a name="BlockCipher.decrypt.3"></a>final void <u>decrypt</u>(ref ubyte[] <i>block</i>);
</big></dt>
<dd>Decrypt a <i>block</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>block</i></td>
<td>the ciphertext <i>block</i> to be decrypted</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length blockSize(). Will hold the result when the function
 has finished.<br><br>

</dd>
<dt><big><a name="BlockCipher.encrypt.4"></a>final void <u>encrypt</u>(Alloc)(ref Vector!(ubyte, Alloc) <i>block</i>);
</big></dt>
<dd>Encrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) block</td>
<td>the input/output buffer (multiple of blockSize())</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.decrypt.4"></a>final void <u>decrypt</u>(Alloc)(ref Vector!(ubyte, Alloc) <i>block</i>);
</big></dt>
<dd>Decrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) block</td>
<td>the input/output buffer (multiple of blockSize())</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.encrypt.5"></a>final void <u>encrypt</u>(Alloc, Alloc2)(auto ref const Vector!(ubyte, Alloc) <i>input</i>, ref Vector!(ubyte, Alloc2) <i>output</i>);
</big></dt>
<dd>Encrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) input</td>
<td>the input buffer (multiple of blockSize())</td></tr>
<tr><td>Vector!(ubyte, Alloc2) output</td>
<td>the output buffer (same size as input)</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.decrypt.5"></a>final void <u>decrypt</u>(Alloc, Alloc2)(auto ref const Vector!(ubyte, Alloc) <i>input</i>, ref Vector!(ubyte, Alloc2) <i>output</i>);
</big></dt>
<dd>Decrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) input</td>
<td>the input buffer (multiple of blockSize())</td></tr>
<tr><td>Vector!(ubyte, Alloc2) output</td>
<td>the output buffer (same size as input)</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.encrypt.6"></a>final void <u>encrypt</u>(ubyte[] <i>input</i>, ref ubyte[] <i>output</i>);
</big></dt>
<dd>Encrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>input</i></td>
<td>the <i>input</i> buffer (multiple of blockSize())</td></tr>
<tr><td>ubyte[] <i>output</i></td>
<td>the <i>output</i> buffer (same size as <i>input</i>)</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.decrypt.6"></a>final void <u>decrypt</u>(ubyte[] <i>input</i>, ref ubyte[] <i>output</i>);
</big></dt>
<dd>Decrypt one or more blocks
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>input</i></td>
<td>the <i>input</i> buffer (multiple of blockSize())</td></tr>
<tr><td>ubyte[] <i>output</i></td>
<td>the <i>output</i> buffer (same size as <i>input</i>)</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.encryptN"></a>abstract void <u>encryptN</u>(const(ubyte)* <i>input</i>, ubyte* <i>output</i>, size_t <i>blocks</i>);
</big></dt>
<dd>Encrypt one or more <i>blocks</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the <i>input</i> buffer (multiple of blockSize())</td></tr>
<tr><td>ubyte* <i>output</i></td>
<td>the <i>output</i> buffer (same size as <i>input</i>)</td></tr>
<tr><td>size_t <i>blocks</i></td>
<td>the number of <i>blocks</i> to process</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.decryptN"></a>abstract void <u>decryptN</u>(const(ubyte)* <i>input</i>, ubyte* <i>output</i>, size_t <i>blocks</i>);
</big></dt>
<dd>Decrypt one or more <i>blocks</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the <i>input</i> buffer (multiple of blockSize())</td></tr>
<tr><td>ubyte* <i>output</i></td>
<td>the <i>output</i> buffer (same size as <i>input</i>)</td></tr>
<tr><td>size_t <i>blocks</i></td>
<td>the number of <i>blocks</i> to process</td></tr>
</table><br>

</dd>
<dt><big><a name="BlockCipher.clone"></a>abstract const BlockCipher <u>clone</u>();
</big></dt>
<dd><b>Returns:</b><br>
new object representing the same algorithm as this<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="BlockCipherFixedParams"></a>class <u>BlockCipherFixedParams</u>(size_t BS, size_t KMIN, size_t KMAX = 0, size_t KMOD = 1): BlockCipher, SymmetricAlgorithm;
</big></dt>
<dd>Represents a block cipher with a single fixed block size<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2009 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
