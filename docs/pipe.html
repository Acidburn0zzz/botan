<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.filters.pipe</title>
        </head><body>
        <h1>botan.filters.pipe</h1>
        <!-- Generated by Ddoc from source/botan/filters/pipe.d -->
Pipe
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="Pipe"></a>struct <u>Pipe</u>;
</big></dt>
<dd>This class represents pipe objects.
 A set of filters can be placed into a pipe, and information flows
 through the pipe until it reaches the end, where the output is
 collected for retrieval.  If you're familiar with the Unix shell
 environment, this design will sound quite familiar.<br><br>

<dl><dt><big><a name="Pipe.message_id"></a>alias <u>message_id</u> = ulong;
</big></dt>
<dd>An opaque type that identifies a message in this Pipe<br><br>

</dd>
<dt><big><a name="Pipe.InvalidMessageNumber"></a>class <u>InvalidMessageNumber</u>: <u>botan.utils.exceptn.InvalidArgument</u>;
</big></dt>
<dd>Exception if you use an invalid message as an argument to
 read, remaining, etc<br><br>

<dl><dt><big><a name="Pipe.InvalidMessageNumber.this"></a>this(in string <i>where</i>, message_id <i>msg</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>string <i>where</i></td>
<td>the error occured</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the invalid message id that was used</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="Pipe.LAST_MESSAGE"></a>static const message_id <u>LAST_MESSAGE</u>;
</big></dt>
<dd>A meta-id for whatever the last message is<br><br>

</dd>
<dt><big><a name="Pipe.DEFAULT_MESSAGE"></a>static const message_id <u>DEFAULT_MESSAGE</u>;
</big></dt>
<dd>A meta-id for the default message (set with set_defaultMsg)<br><br>

</dd>
<dt><big><a name="Pipe.write"></a>void <u>write</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Write <i>input</i> to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the ubyte array to <u>write</u></td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array in</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.2"></a>void <u>write</u>(T, ALLOC)(auto ref const RefCounted!(Vector!(T, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Write input to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(T, ALLOC), ALLOC) input</td>
<td>the SecureVector containing the data to <u>write</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.3"></a>void <u>write</u>(T, ALLOC)(auto ref const Vector!(T, ALLOC) <i>input</i>);
</big></dt>
<dd>Write input to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(T, ALLOC) input</td>
<td>the std::vector containing the data to <u>write</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.4"></a>void <u>write</u>(string <i>input</i>);
</big></dt>
<dd>Write <i>input</i> to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>the string containing the data to <u>write</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.5"></a>void <u>write</u>(DataSource <i>source</i>);
</big></dt>
<dd>Write input to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>DataSource <i>source</i></td>
<td>the DataSource to read the data from</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.6"></a>void <u>write</u>(ubyte <i>input</i>);
</big></dt>
<dd>Write <i>input</i> to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>input</i></td>
<td>a single ubyte to be written</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.write.7"></a>void <u>write</u>(ubyte[] <i>input</i>);
</big></dt>
<dd>Write <i>input</i> to the pipe, i.e. to its first filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>input</i></td>
<td>a ubyte array to be written</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.processMsg"></a>void <u>processMsg</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Perform startMsg(), write() and endMsg() sequentially.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the ubyte array containing the data to write</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array to write</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.processMsg.2"></a>void <u>processMsg</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>);
</big></dt>
<dd>Perform startMsg(), write() and endMsg() sequentially.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>the SecureVector containing the data to write</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.processMsg.3"></a>void <u>processMsg</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Perform startMsg(), write() and endMsg() sequentially.
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) input</td>
<td>the SecureVector containing the data to write</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.processMsg.4"></a>void <u>processMsg</u>(string <i>input</i>);
</big></dt>
<dd>Perform startMsg(), write() and endMsg() sequentially.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>the string containing the data to write</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.processMsg.5"></a>void <u>processMsg</u>(DataSource <i>input</i>);
</big></dt>
<dd>Perform startMsg(), write() and endMsg() sequentially.
<br><br>
<b>Params:</b><br>
<table><tr><td>DataSource <i>input</i></td>
<td>the DataSource providing the data to write</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.remaining"></a>const size_t <u>remaining</u>(message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Find out how many bytes are ready to read.
<br><br>
<b>Params:</b><br>
<table><tr><td>message_id <i>msg</i></td>
<td>the number identifying the message
 for which the information is desired</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes that can still be read<br><br>

</dd>
<dt><big><a name="Pipe.read"></a>size_t <u>read</u>(ubyte* <i>output</i>, size_t <i>length</i>);
</big></dt>
<dd>Read the default message from the pipe. Moves the internal
 offset so that every call to <u>read</u> will return a new portion of
 the message.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>the ubyte array to write the <u>read</u> bytes to</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array <i>output</i></td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually <u>read</u> into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.read.2"></a>size_t <u>read</u>(ubyte* <i>output</i>, size_t <i>length</i>, message_id <i>msg</i>);
</big></dt>
<dd>Read a specified message from the pipe. Moves the internal
 offset so that every call to <u>read</u> will return a new portion of
 the message.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>the ubyte array to write the <u>read</u> bytes to</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array <i>output</i></td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to <u>read</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually <u>read</u> into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.read.3"></a>size_t <u>read</u>(ref ubyte[] <i>output</i>, message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read a specified message from the pipe. Moves the internal
 offset so that every call to <u>read</u> will return a new portion of
 the message.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>output</i></td>
<td>the ubyte array to write the <u>read</u> bytes to</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to <u>read</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually <u>read</u> into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.read.4"></a>size_t <u>read</u>(ref ubyte <i>output</i>, message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read a single ubyte from the pipe. Moves the internal offset so
 that every call to <u>read</u> will return a new portion of the
 message.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>the ubyte to write the result to</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the message to <u>read</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually <u>read</u> into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.readAll"></a>SecureVector!ubyte <u>readAll</u>(message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read the full contents of the pipe.
<br><br>
<b>Params:</b><br>
<table><tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to read from</td></tr>
</table><br>
<b>Returns:</b><br>
SecureVector holding the contents of the pipe<br><br>

</dd>
<dt><big><a name="Pipe.toString"></a>string <u>toString</u>(message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read the full contents of the pipe.
<br><br>
<b>Params:</b><br>
<table><tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to read from</td></tr>
</table><br>
<b>Returns:</b><br>
string holding the contents of the pipe<br><br>

</dd>
<dt><big><a name="Pipe.peek"></a>const size_t <u>peek</u>(ubyte* <i>output</i>, size_t <i>length</i>, size_t <i>offset</i>, message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read from the default message but do not modify the internal
 <i>offset</i>. Consecutive calls to <u>peek</u>() will return portions of
 the message starting at the same position.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>the ubyte array to write the peeked message part to</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array <i>output</i></td></tr>
<tr><td>size_t <i>offset</i></td>
<td>the <i>offset</i> from the current position in message</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to <u>peek</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually peeked and written into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.peek.2"></a>const size_t <u>peek</u>(ref ubyte[] <i>output</i>, size_t <i>offset</i>, message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read from the specified message but do not modify the
 internal <i>offset</i>. Consecutive calls to <u>peek</u>() will return
 portions of the message starting at the same position.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>output</i></td>
<td>the ubyte array to write the peeked message part to</td></tr>
<tr><td>size_t <i>offset</i></td>
<td>the <i>offset</i> from the current position in message</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to <u>peek</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually peeked and written into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.peek.3"></a>const size_t <u>peek</u>(ref ubyte <i>output</i>, size_t <i>offset</i>, message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd>Read a single ubyte from the specified message but do not
 modify the internal <i>offset</i>. Consecutive calls to <u>peek</u>() will
 return portions of the message starting at the same position.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>the ubyte to write the peeked message ubyte to</td></tr>
<tr><td>size_t <i>offset</i></td>
<td>the <i>offset</i> from the current position in message</td></tr>
<tr><td>message_id <i>msg</i></td>
<td>the number identifying the message to <u>peek</u> from</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually peeked and written into <i>output</i><br><br>

</dd>
<dt><big><a name="Pipe.readByte"></a>size_t <u>readByte</u>(ref ubyte <i>output</i>);
</big></dt>
<dd>Read one ubyte.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>the ubyte to read to</td></tr>
</table><br>
<b>Returns:</b><br>
length in bytes that was actually read and put
 into out<br><br>

</dd>
<dt><big><a name="Pipe.peekByte"></a>const size_t <u>peekByte</u>(ref ubyte <i>output</i>);
</big></dt>
<dd>Peek at one ubyte.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>an <i>output</i> ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
length in bytes that was actually read and put
 into out<br><br>

</dd>
<dt><big><a name="Pipe.discardNext"></a>size_t <u>discardNext</u>(size_t <i>n</i>);
</big></dt>
<dd>Discard the next N bytes of the data
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>the number of bytes to discard</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually discarded<br><br>

</dd>
<dt><big><a name="Pipe.getBytesRead"></a>const size_t <u>getBytesRead</u>();
</big></dt>
<dd><b>Returns:</b><br>
the number of bytes read from the default message.<br><br>

</dd>
<dt><big><a name="Pipe.getBytesRead.2"></a>const size_t <u>getBytesRead</u>(message_id <i>msg</i> = DEFAULT_MESSAGE);
</big></dt>
<dd><b>Returns:</b><br>
the number of bytes read from the specified message.<br><br>

</dd>
<dt><big><a name="Pipe.defaultMsg"></a>const size_t <u>defaultMsg</u>();
</big></dt>
<dd><b>Returns:</b><br>
currently set default message<br><br>

</dd>
<dt><big><a name="Pipe.setDefaultMsg"></a>void <u>setDefaultMsg</u>(message_id <i>msg</i>);
</big></dt>
<dd>Set the default message
<br><br>
<b>Params:</b><br>
<table><tr><td>message_id <i>msg</i></td>
<td>the number identifying the message which is going to
 be the new default message</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.messageCount"></a>const message_id <u>messageCount</u>();
</big></dt>
<dd>Get the number of messages the are in this pipe.
<br><br>
<b>Returns:</b><br>
number of messages the are in this pipe<br><br>

</dd>
<dt><big><a name="Pipe.endOfData"></a>const bool <u>endOfData</u>();
</big></dt>
<dd>Test whether this pipe has any data that can be read from.
<br><br>
<b>Returns:</b><br>
<b>true</b> if there is more data to read, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Pipe.startMsg"></a>void <u>startMsg</u>();
</big></dt>
<dd>Start a new message in the pipe. A potential other message in this pipe
 must be closed with endMsg() before this function may be called.<br><br>

</dd>
<dt><big><a name="Pipe.endMsg"></a>void <u>endMsg</u>();
</big></dt>
<dd>End the current message.<br><br>

</dd>
<dt><big><a name="Pipe.prepend"></a>void <u>prepend</u>(Filter <i>filter</i>);
</big></dt>
<dd>Insert a new <i>filter</i> at the front of the pipe
<br><br>
<b>Params:</b><br>
<table><tr><td>Filter <i>filter</i></td>
<td>the new <i>filter</i> to insert</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.append"></a>void <u>append</u>(Filter <i>filter</i>);
</big></dt>
<dd>Insert a new <i>filter</i> at the back of the pipe
<br><br>
<b>Params:</b><br>
<table><tr><td>Filter <i>filter</i></td>
<td>the new <i>filter</i> to insert</td></tr>
</table><br>

</dd>
<dt><big><a name="Pipe.pop"></a>void <u>pop</u>();
</big></dt>
<dd>Remove the first filter at the front of the pipe.<br><br>

</dd>
<dt><big><a name="Pipe.reset"></a>void <u>reset</u>();
</big></dt>
<dd>Reset this pipe to an empty pipe.<br><br>

</dd>
<dt><big><a name="Pipe.this"></a>this(Filter <i>f1</i> = null, Filter <i>f2</i> = null, Filter <i>f3</i> = null, Filter <i>f4</i> = null);
</big></dt>
<dd>Construct a Pipe of up to four filters. The filters are set up
 in the same order as the arguments.<br><br>

</dd>
<dt><big><a name="Pipe.this.2"></a>this(Filter[] <i>filters</i>);
</big></dt>
<dd>Construct a Pipe from a list of <i>filters</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>Filter[] <i>filters</i></td>
<td>the set of <i>filters</i> to use</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon
     2012 Markus Wanner

</small>
        </body></html>
