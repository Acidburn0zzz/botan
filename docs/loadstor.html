<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.utils.loadstor</title>
        </head><body>
        <h1>botan.utils.loadstor</h1>
        <!-- Generated by Ddoc from source/botan/utils/loadstor.d -->
Load/Store Operators
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="make_ushort"></a>ushort <u>make_ushort</u>(ubyte <i>i0</i>, ubyte <i>i1</i>);
</big></dt>
<dd>Make a ushort from two bytes
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>i0</i></td>
<td>the first ubyte</td></tr>
<tr><td>ubyte <i>i1</i></td>
<td>the second ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
<i>i0</i> || <i>i1</i><br><br>

</dd>
<dt><big><a name="make_uint"></a>uint <u>make_uint</u>(ubyte <i>i0</i>, ubyte <i>i1</i>, ubyte <i>i2</i>, ubyte <i>i3</i>);
</big></dt>
<dd>Make a uint from four bytes
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>i0</i></td>
<td>the first ubyte</td></tr>
<tr><td>ubyte <i>i1</i></td>
<td>the second ubyte</td></tr>
<tr><td>ubyte <i>i2</i></td>
<td>the third ubyte</td></tr>
<tr><td>ubyte <i>i3</i></td>
<td>the fourth ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
<i>i0</i> || <i>i1</i> || <i>i2</i> || <i>i3</i><br><br>

</dd>
<dt><big><a name="make_ulong"></a>ulong <u>make_ulong</u>(ubyte <i>i0</i>, ubyte <i>i1</i>, ubyte <i>i2</i>, ubyte <i>i3</i>, ubyte <i>i4</i>, ubyte <i>i5</i>, ubyte <i>i6</i>, ubyte <i>i7</i>);
</big></dt>
<dd>Make a ulong from eight bytes
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>i0</i></td>
<td>the first ubyte</td></tr>
<tr><td>ubyte <i>i1</i></td>
<td>the second ubyte</td></tr>
<tr><td>ubyte <i>i2</i></td>
<td>the third ubyte</td></tr>
<tr><td>ubyte <i>i3</i></td>
<td>the fourth ubyte</td></tr>
<tr><td>ubyte <i>i4</i></td>
<td>the fifth ubyte</td></tr>
<tr><td>ubyte <i>i5</i></td>
<td>the sixth ubyte</td></tr>
<tr><td>ubyte <i>i6</i></td>
<td>the seventh ubyte</td></tr>
<tr><td>ubyte <i>i7</i></td>
<td>the eighth ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
<i>i0</i> || <i>i1</i> || <i>i2</i> || <i>i3</i> || <i>i4</i> || <i>i5</i> || <i>i6</i> || <i>i7</i><br><br>

</dd>
<dt><big><a name="loadBigEndian"></a>T <u>loadBigEndian</u>(T)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a big-endian word
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th T of in, as a big-endian value<br><br>

</dd>
<dt><big><a name="loadLittleEndian"></a>T <u>loadLittleEndian</u>(T)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a little-endian word
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th T of in, as a litte-endian value<br><br>

</dd>
<dt><big><a name="loadBigEndian.2"></a>ushort <u>loadBigEndian</u>(T : ushort)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a big-endian ushort
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th ushort of in, as a big-endian value<br><br>

</dd>
<dt><big><a name="loadLittleEndian.2"></a>ushort <u>loadLittleEndian</u>(T : ushort)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a little-endian ushort
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th ushort of in, as a little-endian value<br><br>

</dd>
<dt><big><a name="loadBigEndian.3"></a>uint <u>loadBigEndian</u>(T : uint)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a big-endian uint
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th uint of in, as a big-endian value<br><br>

</dd>
<dt><big><a name="loadLittleEndian.3"></a>uint <u>loadLittleEndian</u>(T : uint)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a little-endian uint
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th uint of in, as a little-endian value<br><br>

</dd>
<dt><big><a name="loadBigEndian.4"></a>ulong <u>loadBigEndian</u>(T : ulong)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a big-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th ulong of in, as a big-endian value<br><br>

</dd>
<dt><big><a name="loadLittleEndian.4"></a>ulong <u>loadLittleEndian</u>(T : ulong)(const(ubyte)* <i>input</i>, size_t <i>off</i>);
</big></dt>
<dd>Load a little-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>size_t off</td>
<td>an offset into the array</td></tr>
</table><br>
<b>Returns:</b><br>
off'th ulong of in, as a little-endian value<br><br>

</dd>
<dt><big><a name="loadLittleEndian.5"></a>void <u>loadLittleEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>);
</big></dt>
<dd>Load two little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadLittleEndian.6"></a>void <u>loadLittleEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>, ref T <i>x2</i>, ref T <i>x3</i>);
</big></dt>
<dd>Load four little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
<tr><td>T x2</td>
<td>where the third word will be written</td></tr>
<tr><td>T x3</td>
<td>where the fourth word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadLittleEndian.7"></a>void <u>loadLittleEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>, ref T <i>x2</i>, ref T <i>x3</i>, ref T <i>x4</i>, ref T <i>x5</i>, ref T <i>x6</i>, ref T <i>x7</i>);
</big></dt>
<dd>Load eight little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
<tr><td>T x2</td>
<td>where the third word will be written</td></tr>
<tr><td>T x3</td>
<td>where the fourth word will be written</td></tr>
<tr><td>T x4</td>
<td>where the fifth word will be written</td></tr>
<tr><td>T x5</td>
<td>where the sixth word will be written</td></tr>
<tr><td>T x6</td>
<td>where the seventh word will be written</td></tr>
<tr><td>T x7</td>
<td>where the eighth word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadLittleEndian.8"></a>void <u>loadLittleEndian</u>(T)(T* <i>output</i>, const(ubyte)* <i>input</i>, size_t <i>count</i>);
</big></dt>
<dd>Load a variable number of little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>T* output</td>
<td>the output array of words</td></tr>
<tr><td>const(ubyte)* input</td>
<td>the input array of bytes</td></tr>
<tr><td>size_t count</td>
<td>how many words are in in</td></tr>
</table><br>

</dd>
<dt><big><a name="loadBigEndian.5"></a>void <u>loadBigEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>);
</big></dt>
<dd>Load two big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadBigEndian.6"></a>void <u>loadBigEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>, ref T <i>x2</i>, ref T <i>x3</i>);
</big></dt>
<dd>Load four big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
<tr><td>T x2</td>
<td>where the third word will be written</td></tr>
<tr><td>T x3</td>
<td>where the fourth word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadBigEndian.7"></a>void <u>loadBigEndian</u>(T)(const(ubyte)* <i>input</i>, ref T <i>x0</i>, ref T <i>x1</i>, ref T <i>x2</i>, ref T <i>x3</i>, ref T <i>x4</i>, ref T <i>x5</i>, ref T <i>x6</i>, ref T <i>x7</i>);
</big></dt>
<dd>Load eight big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* input</td>
<td>a pointer to some bytes</td></tr>
<tr><td>T x0</td>
<td>where the first word will be written</td></tr>
<tr><td>T x1</td>
<td>where the second word will be written</td></tr>
<tr><td>T x2</td>
<td>where the third word will be written</td></tr>
<tr><td>T x3</td>
<td>where the fourth word will be written</td></tr>
<tr><td>T x4</td>
<td>where the fifth word will be written</td></tr>
<tr><td>T x5</td>
<td>where the sixth word will be written</td></tr>
<tr><td>T x6</td>
<td>where the seventh word will be written</td></tr>
<tr><td>T x7</td>
<td>where the eighth word will be written</td></tr>
</table><br>

</dd>
<dt><big><a name="loadBigEndian.8"></a>void <u>loadBigEndian</u>(T)(T* <i>output</i>, const(ubyte)* <i>input</i>, size_t <i>count</i>);
</big></dt>
<dd>Load a variable number of big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>T* output</td>
<td>the output array of words</td></tr>
<tr><td>const(ubyte)* input</td>
<td>the input array of bytes</td></tr>
<tr><td>size_t count</td>
<td>how many words are in in</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian"></a>void <u>storeBigEndian</u>(ushort <i>input</i>, ubyte[2]* <i>output</i>);
</big></dt>
<dd>Store a big-endian ushort
<br><br>
<b>Params:</b><br>
<table><tr><td>ushort <i>input</i></td>
<td>the <i>input</i> ushort</td></tr>
<tr><td>ubyte[2]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian"></a>void <u>storeLittleEndian</u>(ushort <i>input</i>, ubyte[2]* <i>output</i>);
</big></dt>
<dd>Store a little-endian ushort
<br><br>
<b>Params:</b><br>
<table><tr><td>ushort <i>input</i></td>
<td>the <i>input</i> ushort</td></tr>
<tr><td>ubyte[2]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.2"></a>void <u>storeBigEndian</u>(uint <i>input</i>, ubyte[4]* <i>output</i>);
</big></dt>
<dd>Store a big-endian uint
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>input</i></td>
<td>the <i>input</i> uint</td></tr>
<tr><td>ubyte[4]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.2"></a>void <u>storeLittleEndian</u>(uint <i>input</i>, ubyte[4]* <i>output</i>);
</big></dt>
<dd>Store a little-endian uint
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>input</i></td>
<td>the <i>input</i> uint</td></tr>
<tr><td>ubyte[4]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.3"></a>void <u>storeBigEndian</u>(ulong <i>input</i>, ubyte[8]* <i>output</i>);
</big></dt>
<dd>Store a big-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>ulong <i>input</i></td>
<td>the <i>input</i> ulong</td></tr>
<tr><td>ubyte[8]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.3"></a>void <u>storeLittleEndian</u>(in ulong <i>input</i>, ubyte[8]* <i>output</i>);
</big></dt>
<dd>Store a little-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>ulong <i>input</i></td>
<td>the <i>input</i> ulong</td></tr>
<tr><td>ubyte[8]* <i>output</i></td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.4"></a>void <u>storeLittleEndian</u>(T)(in T <i>input</i>, ubyte* <i>output</i>);
</big></dt>
<dd>Store a little-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>T input</td>
<td>the input ulong</td></tr>
<tr><td>ubyte* output</td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.4"></a>void <u>storeBigEndian</u>(T)(in T <i>input</i>, ubyte* <i>output</i>);
</big></dt>
<dd>Store a big-endian ulong
<br><br>
<b>Params:</b><br>
<table><tr><td>T input</td>
<td>the input ulong</td></tr>
<tr><td>ubyte* output</td>
<td>the ubyte array to write to</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.5"></a>void <u>storeLittleEndian</u>(T)(ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>);
</big></dt>
<dd>Store two little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.5"></a>void <u>storeBigEndian</u>(T)(ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>);
</big></dt>
<dd>Store two big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.6"></a>void <u>storeLittleEndian</u>(T)(ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>, T <i>x2</i>, T <i>x3</i>);
</big></dt>
<dd>Store four little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
<tr><td>T x2</td>
<td>the third word</td></tr>
<tr><td>T x3</td>
<td>the fourth word</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.6"></a>void <u>storeBigEndian</u>(T)(ref ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>, T <i>x2</i>, T <i>x3</i>);
</big></dt>
<dd>Store four big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
<tr><td>T x2</td>
<td>the third word</td></tr>
<tr><td>T x3</td>
<td>the fourth word</td></tr>
</table><br>

</dd>
<dt><big><a name="storeLittleEndian.7"></a>void <u>storeLittleEndian</u>(T)(ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>, T <i>x2</i>, T <i>x3</i>, T <i>x4</i>, T <i>x5</i>, T <i>x6</i>, T <i>x7</i>);
</big></dt>
<dd>Store eight little-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
<tr><td>T x2</td>
<td>the third word</td></tr>
<tr><td>T x3</td>
<td>the fourth word</td></tr>
<tr><td>T x4</td>
<td>the fifth word</td></tr>
<tr><td>T x5</td>
<td>the sixth word</td></tr>
<tr><td>T x6</td>
<td>the seventh word</td></tr>
<tr><td>T x7</td>
<td>the eighth word</td></tr>
</table><br>

</dd>
<dt><big><a name="storeBigEndian.7"></a>void <u>storeBigEndian</u>(T)(ubyte* <i>output</i>, T <i>x0</i>, T <i>x1</i>, T <i>x2</i>, T <i>x3</i>, T <i>x4</i>, T <i>x5</i>, T <i>x6</i>, T <i>x7</i>);
</big></dt>
<dd>Store eight big-endian words
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>the output ubyte array</td></tr>
<tr><td>T x0</td>
<td>the first word</td></tr>
<tr><td>T x1</td>
<td>the second word</td></tr>
<tr><td>T x2</td>
<td>the third word</td></tr>
<tr><td>T x3</td>
<td>the fourth word</td></tr>
<tr><td>T x4</td>
<td>the fifth word</td></tr>
<tr><td>T x5</td>
<td>the sixth word</td></tr>
<tr><td>T x6</td>
<td>the seventh word</td></tr>
<tr><td>T x7</td>
<td>the eighth word</td></tr>
</table><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon
      2007 Yves Jerschow

</small>
        </body></html>
