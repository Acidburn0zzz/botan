<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.tls.session</title>
        </head><body>
        <h1>botan.tls.session</h1>
        <!-- Generated by Ddoc from source/botan/tls/session.d -->
TLS Session
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="TLSSession"></a>struct <u>TLSSession</u>;
</big></dt>
<dd>Class representing a TLS session state<br><br>

<dl><dt><big><a name="TLSSession.this"></a>this(Vector!ubyte <i>session_identifier</i>, SecureVector!ubyte <i>master_secret</i>, TLSProtocolVersion <i>_version</i>, ushort <i>ciphersuite</i>, ubyte <i>compression_method</i>, ConnectionSide <i>side</i>, size_t <i>fragment_size</i>, Vector!X509Certificate <i>certs</i>, Vector!ubyte <i>ticket</i>, in TLSServerInformation <i>server_info</i>, in string <i>srp_identifier</i>);
</big></dt>
<dd>New session (sets session start time)<br><br>

</dd>
<dt><big><a name="TLSSession.this.2"></a>this(const(ubyte)* <i>ber</i>, size_t <i>ber_len</i>);
</big></dt>
<dd>Load a session from DER representation (created by DER_encode)<br><br>

</dd>
<dt><big><a name="TLSSession.this.3"></a>this(in string <i>pem</i>);
</big></dt>
<dd>Load a session from PEM representation (created by PEM_encode)<br><br>

</dd>
<dt><big><a name="TLSSession.DER_encode"></a>const SecureVector!ubyte <u>DER_encode</u>();
</big></dt>
<dd>Encode this session data for storage
<br><br>
<b>Notes:</b><br>
if the master secret is compromised so is the session traffic<br><br>

</dd>
<dt><big><a name="TLSSession.encrypt"></a>const Vector!ubyte <u>encrypt</u>(in SymmetricKey <i>master_key</i>, RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Encrypt a session (useful for serialization or session tickets)<br><br>

</dd>
<dt><big><a name="TLSSession.decrypt"></a>static TLSSession <u>decrypt</u>(const(ubyte)* <i>buf</i>, size_t <i>buf_len</i>, in SymmetricKey <i>master_key</i>);
</big></dt>
<dd>Decrypt a session created by encrypt
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>buf</i></td>
<td>the ciphertext returned by encrypt</td></tr>
<tr><td>size_t <i>buf_len</i></td>
<td>the size of ctext in bytes</td></tr>
<tr><td>SymmetricKey <i>master_key</i></td>
<td>the same key used by the encrypting side</td></tr>
</table><br>

</dd>
<dt><big><a name="TLSSession.decrypt.2"></a>static TLSSession <u>decrypt</u>(ref const Vector!ubyte <i>ctext</i>, in SymmetricKey <i>key</i>);
</big></dt>
<dd>Decrypt a session created by encrypt
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!ubyte <i>ctext</i></td>
<td>the ciphertext returned by encrypt</td></tr>
<tr><td>SymmetricKey <i>key</i></td>
<td>the same <i>key</i> used by the encrypting side</td></tr>
</table><br>

</dd>
<dt><big><a name="TLSSession.PEM_encode"></a>const string <u>PEM_encode</u>();
</big></dt>
<dd>Encode this session data for storage
<br><br>
<b>Notes:</b><br>
if the master secret is compromised so is the session traffic<br><br>

</dd>
<dt><big><a name="TLSSession.Version"></a>const TLSProtocolVersion <u>Version</u>();
</big></dt>
<dd>Get the version of the saved session<br><br>

</dd>
<dt><big><a name="TLSSession.ciphersuiteCode"></a>const ushort <u>ciphersuiteCode</u>();
</big></dt>
<dd>Get the ciphersuite code of the saved session<br><br>

</dd>
<dt><big><a name="TLSSession.ciphersuite"></a>const const(TLSCiphersuite) <u>ciphersuite</u>();
</big></dt>
<dd>Get the <u>ciphersuite</u> info of the saved session<br><br>

</dd>
<dt><big><a name="TLSSession.compressionMethod"></a>const ubyte <u>compressionMethod</u>();
</big></dt>
<dd>Get the compression method used in the saved session<br><br>

</dd>
<dt><big><a name="TLSSession.side"></a>const const(ConnectionSide) <u>side</u>();
</big></dt>
<dd>Get which <u>side</u> of the connection the resumed session we are/were
 acting as.<br><br>

</dd>
<dt><big><a name="TLSSession.srpIdentifier"></a>const string <u>srpIdentifier</u>();
</big></dt>
<dd>Get the SRP identity (if sent by the client in the initial handshake)<br><br>

</dd>
<dt><big><a name="TLSSession.masterSecret"></a>const ref const(SecureVector!ubyte) <u>masterSecret</u>();
</big></dt>
<dd>Get the saved master secret<br><br>

</dd>
<dt><big><a name="TLSSession.sessionId"></a>const ref const(Vector!ubyte) <u>sessionId</u>();
</big></dt>
<dd>Get the session identifier<br><br>

</dd>
<dt><big><a name="TLSSession.fragmentSize"></a>const size_t <u>fragmentSize</u>();
</big></dt>
<dd>Get the negotiated maximum fragment size (or 0 if default)<br><br>

</dd>
<dt><big><a name="TLSSession.peerCerts"></a>const ref const(Vector!X509Certificate) <u>peerCerts</u>();
</big></dt>
<dd>Return the certificate chain of the peer (possibly empty)<br><br>

</dd>
<dt><big><a name="TLSSession.startTime"></a>const SysTime <u>startTime</u>();
</big></dt>
<dd>Get the wall clock time this session began<br><br>

</dd>
<dt><big><a name="TLSSession.sessionAge"></a>const const(Duration) <u>sessionAge</u>();
</big></dt>
<dd>Return how long this session has existed (in seconds)<br><br>

</dd>
<dt><big><a name="TLSSession.sessionTicket"></a>const ref const(Vector!ubyte) <u>sessionTicket</u>();
</big></dt>
<dd>Return the session ticket the server gave us<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2011-2012 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
