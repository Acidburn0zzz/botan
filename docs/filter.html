<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.filters.filter</title>
        </head><body>
        <h1>botan.filters.filter</h1>
        <!-- Generated by Ddoc from source/botan/filters/filter.d -->
Filter
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="Filter"></a>abstract class <u>Filter</u>: <u>botan.filters.filter.Filterable</u>;
</big></dt>
<dd>This class represents general abstract filter objects.<br><br>

<dl><dt><big><a name="Filter.write"></a>final void <u>write</u>(const(ubyte)[] <i>input</i>);
</big></dt>
<dd>Write a portion of a message to this filter.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)[] <i>input</i></td>
<td>the <i>input</i> as a ubyte array</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send"></a>void <u>send</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>some <i>input</i> for the filter</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of in</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send.2"></a>final void <u>send</u>(ubyte <i>input</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>ubyte <i>input</i></td>
<td>some <i>input</i> for the filter</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send.3"></a>final void <u>send</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>some input for the filter</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send.4"></a>final void <u>send</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) input</td>
<td>some input for the filter</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send.5"></a>final void <u>send</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>some input for the filter</td></tr>
<tr><td>size_t length</td>
<td>the number of bytes of in to <u>send</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.send.6"></a>final void <u>send</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) input</td>
<td>some input for the filter</td></tr>
<tr><td>size_t length</td>
<td>the number of bytes of in to <u>send</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.newMsg"></a>void <u>newMsg</u>();
</big></dt>
<dd>Start a new message in this and all following filters. Only for
 internal use, not intended for use in client applications.<br><br>

</dd>
<dt><big><a name="Filter.finishMsg"></a>void <u>finishMsg</u>();
</big></dt>
<dd>End a new message in this and all following filters. Only for
 internal use, not intended for use in client applications.<br><br>

</dd>
<dt><big><a name="Filter.setPort"></a>void <u>setPort</u>(size_t <i>new_port</i>);
</big></dt>
<dd>Set the active port
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>new_port</i></td>
<td>the new value</td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.attach"></a>void <u>attach</u>(Filter <i>new_filter</i>);
</big></dt>
<dd>Attach another filter to this one
<br><br>
<b>Params:</b><br>
<table><tr><td>Filter <i>new_filter</i></td>
<td>filter to <u>attach</u></td></tr>
</table><br>

</dd>
<dt><big><a name="Filter.setNext"></a>void <u>setNext</u>(Filter* <i>filters</i>, size_t <i>size</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Filter* <i>filters</i></td>
<td>the <i>filters</i> to set</td></tr>
<tr><td>size_t <i>size</i></td>
<td>number of items in <i>filters</i></td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="FanoutFilter"></a>abstract class <u>FanoutFilter</u>: <u>botan.filters.filter.Filter</u>, <u>botan.filters.filter.Filterable</u>;
</big></dt>
<dd>This is the abstract <u>FanoutFilter</u> base class.<br><br>

<dl><dt><big><a name="FanoutFilter.incrOwns"></a>protected void <u>incrOwns</u>();
</big></dt>
<dd>Increment the number of filters past us that we own<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="DecoderChecking"></a>alias <u>DecoderChecking</u> = ubyte;
</big></dt>
<dd>The type of checking to be performed by decoders:
 NONE - no checks, IGNORE_WS - perform checks, but ignore
 whitespaces, FULL_CHECK - perform checks, also complain
 about white spaces.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon
 (C) 2013 Joel Low

</small>
        </body></html>
