<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.algo_base.symkey</title>
        </head><body>
        <h1>botan.algo_base.symkey</h1>
        <!-- Generated by Ddoc from source/botan/algo_base/symkey.d -->
OctetString
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="OctetStringImpl"></a>struct <u>OctetStringImpl</u>;
</big></dt>
<dd>Octet String<br><br>

<dl><dt><big><a name="OctetStringImpl.length"></a>const @property size_t <u>length</u>();
</big></dt>
<dd><b>Returns:</b><br>
size of this octet string in bytes<br><br>

</dd>
<dt><big><a name="OctetStringImpl.bitsOf"></a>const SecureVector!ubyte <u>bitsOf</u>();
</big></dt>
<dd><b>Returns:</b><br>
this object as a <br><br>

</dd>
<dt><big><a name="OctetStringImpl.ptr"></a>const @property ubyte* <u>ptr</u>();
</big></dt>
<dd><b>Returns:</b><br>
Pointer to the first ubyte of this string<br><br>

</dd>
<dt><big><a name="OctetStringImpl.end"></a>const ubyte* <u>end</u>();
</big></dt>
<dd><b>Returns:</b><br>
Pointer to one past the <u>end</u> of this string<br><br>

</dd>
<dt><big><a name="OctetStringImpl.toString"></a>const string <u>toString</u>();
</big></dt>
<dd><b>Returns:</b><br>
this encoded as hex<br><br>

</dd>
<dt><big><a name="OctetStringImpl.opOpAssign"></a>OctetString <u>opOpAssign</u>(string op)(in OctetString <i>other</i>) if (op == "^");
</big></dt>
<dd>XOR the contents of another octet string into this one
<br><br>
<b>Params:</b><br>
<table><tr><td>OctetString other</td>
<td>octet string</td></tr>
</table><br>
<b>Returns:</b><br>
reference to this<br><br>

</dd>
<dt><big><a name="OctetStringImpl.setOddParity"></a>void <u>setOddParity</u>();
</big></dt>
<dd>Force to have odd parity<br><br>

</dd>
<dt><big><a name="OctetStringImpl.this"></a>this(in string <i>hex_string</i> = "");
</big></dt>
<dd>Create a new OctetString
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>hex_string</i></td>
<td>A hex encoded string</td></tr>
</table><br>

</dd>
<dt><big><a name="OctetStringImpl.this.2"></a>this(RandomNumberGenerator <i>rng</i>, size_t <i>len</i>);
</big></dt>
<dd>Create a new random OctetString
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>is a random number generator</td></tr>
<tr><td>size_t <i>len</i></td>
<td>is the desired length in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="OctetStringImpl.this.3"></a>this(const(ubyte)* <i>input</i>, size_t <i>len</i>);
</big></dt>
<dd>Create a new OctetString
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>is an array</td></tr>
<tr><td>size_t <i>len</i></td>
<td>is the length of in in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="OctetStringImpl.this.4"></a>this(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>);
<br>this(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Create a new OctetString
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>a bytestring</td></tr>
</table><br>

</dd>
<dt><big><a name="OctetStringImpl.opEquals"></a>const bool <u>opEquals</u>(ref const OctetString <i>other</i>);
</big></dt>
<dd>Compare two strings
<br><br>
<b>Params:</b><br>
<table><tr><td>OctetString <i>other</i></td>
<td>an octet string</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if x is equal to y<br><br>

</dd>
<dt><big><a name="OctetStringImpl.opCmp"></a>const int <u>opCmp</u>(ref const OctetString <i>other</i>);
</big></dt>
<dd>Compare two strings
<br><br>
<b>Params:</b><br>
<table><tr><td>OctetString <i>other</i></td>
<td>an octet string</td></tr>
</table><br>
<b>Returns:</b><br>
1 if this is bigger, -1 if smaller, 0 if equal to <i>other</i><br><br>

</dd>
<dt><big><a name="OctetStringImpl.opOpAssign.2"></a>void <u>opOpAssign</u>(string op)(auto ref const OctetString <i>other</i>) if (op == "~");
</big></dt>
<dd>Append another  to this<br><br>

</dd>
<dt><big><a name="OctetStringImpl.opBinary"></a>OctetString <u>opBinary</u>(string op)(auto ref const OctetString <i>other</i>) if (op == "~");
</big></dt>
<dd>Concatenate two strings
<br><br>
<b>Params:</b><br>
<table><tr><td>OctetString other</td>
<td>an octet string</td></tr>
</table><br>
<b>Returns:</b><br>
this concatenated with other<br><br>

</dd>
<dt><big><a name="OctetStringImpl.opBinary.2"></a>OctetString <u>opBinary</u>(string op)(auto ref const OctetString <i>other</i>) if (op == "^");
</big></dt>
<dd>XOR two strings
<br><br>
<b>Params:</b><br>
<table><tr><td>OctetString other</td>
<td>an octet string</td></tr>
</table><br>
<b>Returns:</b><br>
this XORed with other<br><br>

</dd>
<dt><big><a name="OctetStringImpl.dup"></a>const @property OctetString <u>dup</u>();
</big></dt>
<dd><b>Returns:</b><br>
A copy of the underlying bits in a new octet string<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="SymmetricKey"></a>alias <u>SymmetricKey</u> = memutils.refcounted.RefCounted!(OctetStringImpl, ThreadMem).RefCounted;
</big></dt>
<dd>Alternate name for octet string showing intent to use as a key<br><br>

</dd>
<dt><big><a name="InitializationVector"></a>alias <u>InitializationVector</u> = memutils.refcounted.RefCounted!(OctetStringImpl, ThreadMem).RefCounted;
</big></dt>
<dd>Alternate name for octet string showing intent to use as an IV<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
