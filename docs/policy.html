<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.tls.policy</title>
        </head><body>
        <h1>botan.tls.policy</h1>
        <!-- Generated by Ddoc from source/botan/tls/policy.d -->
Hooks for application level policies on TLS connections
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="TLSPolicy"></a>class <u>TLSPolicy</u>;
</big></dt>
<dd>TLS <u>TLSPolicy</u> Base Class
 Inherit and overload as desired to suit local policy concerns<br><br>

<dl><dt><big><a name="TLSPolicy.allowedCiphers"></a>const Vector!string <u>allowedCiphers</u>();
</big></dt>
<dd>Returns a list of ciphers we are willing to negotiate, in
 order of preference.<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowedSignatureHashes"></a>const Vector!string <u>allowedSignatureHashes</u>();
</big></dt>
<dd>Returns a list of hash algorithms we are willing to use for
 signatures, in order of preference.<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowedMacs"></a>const Vector!string <u>allowedMacs</u>();
</big></dt>
<dd>Returns a list of MAC algorithms we are willing to use.<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowedKeyExchangeMethods"></a>const Vector!string <u>allowedKeyExchangeMethods</u>();
</big></dt>
<dd>Returns a list of key exchange algorithms we are willing to
 use, in order of preference. Allowed values: DH, empty string
 (representing RSA using server certificate key)<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowedSignatureMethods"></a>const Vector!string <u>allowedSignatureMethods</u>();
</big></dt>
<dd>Returns a list of signature algorithms we are willing to
 use, in order of preference. Allowed values RSA and DSA.<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowedEccCurves"></a>const Vector!string <u>allowedEccCurves</u>();
</big></dt>
<dd>Return list of ECC curves we are willing to use in order of preference<br><br>

</dd>
<dt><big><a name="TLSPolicy.compression"></a>const Vector!ubyte <u>compression</u>();
</big></dt>
<dd>Returns a list of <u>compression</u> algorithms we are willing to use,
 in order of preference. Allowed values any value of
 Compression_Method.
<br><br>
@note Compression is not currently supported<br><br>

</dd>
<dt><big><a name="TLSPolicy.chooseCurve"></a>const string <u>chooseCurve</u>(in Vector!string <i>curve_names</i>);
</big></dt>
<dd>Choose an elliptic curve to use<br><br>

</dd>
<dt><big><a name="TLSPolicy.negotiateHeartbeatSupport"></a>const bool <u>negotiateHeartbeatSupport</u>();
</big></dt>
<dd>Attempt to negotiate the use of the heartbeat extension<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowInsecureRenegotiation"></a>const bool <u>allowInsecureRenegotiation</u>();
</big></dt>
<dd>Allow renegotiation even if the counterparty doesn't
 support the secure renegotiation extension.
<br><br>
<b>Notes:</b><br>
Changing this to <b>true</b> exposes you to injected plaintext attacks.
  Read RFC 5746 for background.<br><br>

</dd>
<dt><big><a name="TLSPolicy.allowServerInitiatedRenegotiation"></a>const bool <u>allowServerInitiatedRenegotiation</u>();
</big></dt>
<dd>Allow servers to initiate a new handshake<br><br>

</dd>
<dt><big><a name="TLSPolicy.dhGroup"></a>const DLGroup <u>dhGroup</u>();
</big></dt>
<dd>Return the group to use for ephemeral Diffie-Hellman key agreement<br><br>

</dd>
<dt><big><a name="TLSPolicy.minimumDhGroupSize"></a>const size_t <u>minimumDhGroupSize</u>();
</big></dt>
<dd>Return the minimum DH group size we're willing to use<br><br>

</dd>
<dt><big><a name="TLSPolicy.hideUnknownUsers"></a>const bool <u>hideUnknownUsers</u>();
</big></dt>
<dd>If this function returns <b>false</b>, unknown SRP/PSK identifiers
 will be rejected with an unknown_psk_identifier alert as soon
 as the non-existence is identified. Otherwise, a <b>false</b>
 identifier value will be used and the protocol allowed to
 proceed, causing the handshake to eventually fail without
 revealing that the username does not exist on this system.<br><br>

</dd>
<dt><big><a name="TLSPolicy.sessionTicketLifetime"></a>const Duration <u>sessionTicketLifetime</u>();
</big></dt>
<dd>Return the allowed lifetime of a session ticket. If 0, session
 tickets do not expire until the session ticket key rolls over.
 Expired session tickets cannot be used to resume a session.<br><br>

</dd>
<dt><big><a name="TLSPolicy.acceptableProtocolVersion"></a>const bool <u>acceptableProtocolVersion</u>(TLSProtocolVersion <i>_version</i>);
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> if and only if we are willing to accept this version
 Default accepts only TLS, so if you want to enable DTLS override
 in your application.<br><br>

</dd>
<dt><big><a name="TLSPolicy.serverUsesOwnCiphersuitePreferences"></a>const bool <u>serverUsesOwnCiphersuitePreferences</u>();
</big></dt>
<dd><b>Returns:</b><br>
<b>true</b> if servers should choose the ciphersuite matching
            their highest preference, rather than the clients.
            Has no effect on client side.<br><br>

</dd>
<dt><big><a name="TLSPolicy.ciphersuiteList"></a>const Vector!ushort <u>ciphersuiteList</u>(TLSProtocolVersion <i>_version</i>, bool <i>have_srp</i>);
</big></dt>
<dd>Return allowed ciphersuites, in order of preference<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="NSASuiteB128"></a>class <u>NSASuiteB128</u>: <u>botan.tls.policy.TLSPolicy</u>;
</big></dt>
<dd>NSA Suite B 128-bit security level (see @rfc 6460)<br><br>

</dd>
<dt><big><a name="DatagramPolicy"></a>class <u>DatagramPolicy</u>: <u>botan.tls.policy.TLSPolicy</u>;
</big></dt>
<dd>TLSPolicy for DTLS. We require DTLS v1.2 and an AEAD mode<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2004-2006,2013 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
