<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.pbkdf.pbkdf</title>
        </head><body>
        <h1>botan.pbkdf.pbkdf</h1>
        <!-- Generated by Ddoc from source/botan/pbkdf/pbkdf.d -->
PBKDF
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="PBKDF"></a>interface <u>PBKDF</u>;
</big></dt>
<dd>Base class for <u>PBKDF</u> (password based key derivation function)
 implementations. Converts a password into a key using a salt
 and iterated hashing to make brute force attacks harder.<br><br>

<dl><dt><big><a name="PBKDF.clone"></a>abstract const PBKDF <u>clone</u>();
</big></dt>
<dd><b>Returns:</b><br>
new instance of this same algorithm<br><br>

</dd>
<dt><big><a name="PBKDF.deriveKey"></a>final const OctetString <u>deriveKey</u>(size_t <i>output_len</i>, in string <i>passphrase</i>, const(ubyte)* <i>salt</i>, size_t <i>salt_len</i>, size_t <i>iterations</i>);
</big></dt>
<dd>Derive a key from a <i>passphrase</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>output_len</i></td>
<td>the desired length of the key to produce</td></tr>
<tr><td>string <i>passphrase</i></td>
<td>the password to derive the key from</td></tr>
<tr><td>const(ubyte)* <i>salt</i></td>
<td>a randomly chosen <i>salt</i></td></tr>
<tr><td>size_t <i>salt_len</i></td>
<td>length of <i>salt</i> in bytes</td></tr>
<tr><td>size_t <i>iterations</i></td>
<td>the number of <i>iterations</i> to use (use 10K or more)</td></tr>
</table><br>

</dd>
<dt><big><a name="PBKDF.deriveKey.2"></a>final const OctetString <u>deriveKey</u>(Alloc)(size_t <i>output_len</i>, in string <i>passphrase</i>, ref const Vector!(ubyte, Alloc) <i>salt</i>, size_t <i>iterations</i>);
</big></dt>
<dd>Derive a key from a passphrase
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t output_len</td>
<td>the desired length of the key to produce</td></tr>
<tr><td>string passphrase</td>
<td>the password to derive the key from</td></tr>
<tr><td>Vector!(ubyte, Alloc) salt</td>
<td>a randomly chosen salt</td></tr>
<tr><td>size_t iterations</td>
<td>the number of iterations to use (use 10K or more)</td></tr>
</table><br>

</dd>
<dt><big><a name="PBKDF.deriveKey.3"></a>final const OctetString <u>deriveKey</u>(size_t <i>output_len</i>, in string <i>passphrase</i>, const(ubyte)* <i>salt</i>, size_t <i>salt_len</i>, Duration <i>loop_for</i>, ref size_t <i>iterations</i>);
</big></dt>
<dd>Derive a key from a <i>passphrase</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>output_len</i></td>
<td>the desired length of the key to produce</td></tr>
<tr><td>string <i>passphrase</i></td>
<td>the password to derive the key from</td></tr>
<tr><td>const(ubyte)* <i>salt</i></td>
<td>a randomly chosen <i>salt</i></td></tr>
<tr><td>size_t <i>salt_len</i></td>
<td>length of <i>salt</i> in bytes</td></tr>
<tr><td>Duration <i>loop_for</i></td>
<td>is how long to run the PBKDF</td></tr>
<tr><td>size_t <i>iterations</i></td>
<td>is set to the number of <i>iterations</i> used</td></tr>
</table><br>

</dd>
<dt><big><a name="PBKDF.deriveKey.4"></a>final const OctetString <u>deriveKey</u>(Alloc)(size_t <i>output_len</i>, in string <i>passphrase</i>, ref const Vector!(ubyte, Alloc) <i>salt</i>, Duration <i>loop_for</i>, ref size_t <i>iterations</i>);
</big></dt>
<dd>Derive a key from a passphrase using a certain amount of time
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t output_len</td>
<td>the desired length of the key to produce</td></tr>
<tr><td>string passphrase</td>
<td>the password to derive the key from</td></tr>
<tr><td>Vector!(ubyte, Alloc) salt</td>
<td>a randomly chosen salt</td></tr>
<tr><td>Duration loop_for</td>
<td>is how long to run the PBKDF</td></tr>
<tr><td>size_t iterations</td>
<td>is set to the number of iterations used</td></tr>
</table><br>

</dd>
<dt><big><a name="PBKDF.keyDerivation"></a>abstract const Pair!(size_t, OctetString) <u>keyDerivation</u>(size_t <i>output_len</i>, in string <i>passphrase</i>, const(ubyte)* <i>salt</i>, size_t <i>salt_len</i>, size_t <i>iterations</i>, Duration <i>loop_for</i>);
</big></dt>
<dd>Derive a key from a <i>passphrase</i> for a number of <i>iterations</i>
 specified by either <i>iterations</i> or if <i>iterations</i> == 0 then
 running until seconds time has elapsed.
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>output_len</i></td>
<td>the desired length of the key to produce</td></tr>
<tr><td>string <i>passphrase</i></td>
<td>the password to derive the key from</td></tr>
<tr><td>const(ubyte)* <i>salt</i></td>
<td>a randomly chosen <i>salt</i></td></tr>
<tr><td>size_t <i>salt_len</i></td>
<td>length of <i>salt</i> in bytes</td></tr>
<tr><td>size_t <i>iterations</i></td>
<td>the number of <i>iterations</i> to use (use 10K or more)</td></tr>
<tr><td>Duration <i>loop_for</i></td>
<td>if <i>iterations</i> is zero, then instead the PBKDF is
          run until duration has passed.</td></tr>
</table><br>
<b>Returns:</b><br>
the number of <i>iterations</i> performed and the derived key<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007,2012 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
