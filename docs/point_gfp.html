<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.math.ec_gfp.point_gfp</title>
        </head><body>
        <h1>botan.math.ec_gfp.point_gfp</h1>
        <!-- Generated by Ddoc from source/botan/math/ec_gfp/point_gfp.d -->
Point arithmetic on elliptic curves over GF(p)
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="IllegalTransformation"></a>class <u>IllegalTransformation</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown if you try to convert a zero point to an affine
 coordinate<br><br>

</dd>
<dt><big><a name="IllegalPoint"></a>class <u>IllegalPoint</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown if some form of illegal point is decoded<br><br>

</dd>
<dt><big><a name="PointGFp"></a>struct <u>PointGFp</u>;
</big></dt>
<dd>This class represents one point on a curve of GF(p)<br><br>

<dl><dt><big><a name="PointGFp.this"></a>this()(auto ref const CurveGFp <i>curve</i>);
</big></dt>
<dd>Construct the zero point
<br><br>
<b>Params:</b><br>
<table><tr><td>CurveGFp curve</td>
<td>The base curve</td></tr>
</table><br>

</dd>
<dt><big><a name="PointGFp.this.2"></a>this()(auto ref PointGFp <i>other</i>);
</big></dt>
<dd>Move Constructor<br><br>

</dd>
<dt><big><a name="PointGFp.opAssign"></a>ref PointGFp <u>opAssign</u>(PointGFp <i>other</i>);
</big></dt>
<dd>Move Assignment<br><br>

</dd>
<dt><big><a name="PointGFp.this.3"></a>this(ref const CurveGFp <i>curve</i>, ref const BigInt <i>x</i>, ref const BigInt <i>y</i>);
</big></dt>
<dd>Construct a point from its affine coordinates
<br><br>
<b>Params:</b><br>
<table><tr><td>CurveGFp <i>curve</i></td>
<td>the base <i>curve</i></td></tr>
<tr><td>BigInt <i>x</i></td>
<td>affine <i>x</i> coordinate</td></tr>
<tr><td>BigInt <i>y</i></td>
<td>affine <i>y</i> coordinate</td></tr>
</table><br>

</dd>
<dt><big><a name="PointGFp.opOpAssign"></a>void <u>opOpAssign</u>(string op)(ref const PointGFp <i>rhs</i>) if (op == "+");
</big></dt>
<dd>+= Operator
<br><br>
<b>Params:</b><br>
<table><tr><td>PointGFp rhs</td>
<td>the PointGFp to add to the local value</td></tr>
</table><br>
<b>Returns:</b><br>
resulting PointGFp<br><br>

</dd>
<dt><big><a name="PointGFp.opOpAssign.2"></a>void <u>opOpAssign</u>(string op)(ref const PointGFp <i>rhs</i>) if (op == "-");
</big></dt>
<dd> -= Operator
<br><br>
<b>Params:</b><br>
<table><tr><td>PointGFp rhs</td>
<td>the PointGFp to subtract from the local value</td></tr>
</table><br>
<b>Returns:</b><br>
resulting PointGFp<br><br>

</dd>
<dt><big><a name="PointGFp.opOpAssign.3"></a>void <u>opOpAssign</u>(string op)(auto ref const BigInt <i>scalar</i>) if (op == "*");
</big></dt>
<dd>*= Operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt scalar</td>
<td>the PointGFp to multiply with this</td></tr>
</table><br>
<b>Returns:</b><br>
resulting PointGFp<br><br>

</dd>
<dt><big><a name="PointGFp.opBinary"></a>const PointGFp <u>opBinary</u>(string op)(auto ref const BigInt <i>scalar</i>) if (op == "*");
</big></dt>
<dd>Multiplication Operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt scalar</td>
<td>the scalar value</td></tr>
</table><br>
<b>Returns:</b><br>
scalar*point on the curve<br><br>

</dd>
<dt><big><a name="PointGFp.multiExponentiate"></a>static PointGFp <u>multiExponentiate</u>(ref const PointGFp <i>p1</i>, ref const BigInt <i>z1</i>, ref const PointGFp <i>p2</i>, ref const BigInt <i>z2</i>);
</big></dt>
<dd>Multiexponentiation
<br><br>
<b>Params:</b><br>
<table><tr><td>PointGFp <i>p1</i></td>
<td>a point</td></tr>
<tr><td>BigInt <i>z1</i></td>
<td>a scalar</td></tr>
<tr><td>PointGFp <i>p2</i></td>
<td>a point</td></tr>
<tr><td>BigInt <i>z2</i></td>
<td>a scalar</td></tr>
</table><br>
<b>Returns:</b><br>
(<i>p1</i> * <i>z1</i> + <i>p2</i> * <i>z2</i>)<br><br>

</dd>
<dt><big><a name="PointGFp.negate"></a>ref PointGFp <u>negate</u>();
</big></dt>
<dd>Negate this point
<br><br>
<b>Returns:</b><br>
this<br><br>

</dd>
<dt><big><a name="PointGFp.getCurve"></a>const ref const(CurveGFp) <u>getCurve</u>();
</big></dt>
<dd>Return base curve of this point
<br><br>
<b>Returns:</b><br>
the curve over GF(p) of this point<br><br>

</dd>
<dt><big><a name="PointGFp.getAffineX"></a>const BigInt <u>getAffineX</u>();
</big></dt>
<dd>get affine x coordinate
<br><br>
<b>Returns:</b><br>
affine x coordinate<br><br>

</dd>
<dt><big><a name="PointGFp.getAffineY"></a>const BigInt <u>getAffineY</u>();
</big></dt>
<dd>get affine y coordinate
<br><br>
<b>Returns:</b><br>
affine y coordinate<br><br>

</dd>
<dt><big><a name="PointGFp.isZero"></a>const bool <u>isZero</u>();
</big></dt>
<dd>Is this the point at infinity?
<br><br>
<b>Returns:</b><br>
<b>true</b>, if this point is at infinity, <b>false</b> otherwise.<br><br>

</dd>
<dt><big><a name="PointGFp.onTheCurve"></a>const bool <u>onTheCurve</u>();
</big></dt>
<dd>Checks whether the point is to be found on the underlying
 curve; used to prevent fault attacks.
<br><br>
<b>Returns:</b><br>
if the point is on the curve<br><br>

</dd>
<dt><big><a name="PointGFp.swap"></a>void <u>swap</u>()(auto ref PointGFp <i>other</i>);
</big></dt>
<dd>swaps the states of this and other, does not throw!
<br><br>
<b>Params:</b><br>
<table><tr><td>PointGFp other</td>
<td>the object to <u>swap</u> values with</td></tr>
</table><br>

</dd>
<dt><big><a name="PointGFp.opEquals"></a>const bool <u>opEquals</u>(ref const PointGFp <i>other</i>);
</big></dt>
<dd>Equality operator<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2007 Martin Doering, Christoph Ludwig, Falko Strenzke
      2008-2011 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
