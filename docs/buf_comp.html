<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.algo_base.buf_comp</title>
        </head><body>
        <h1>botan.algo_base.buf_comp</h1>
        <!-- Generated by Ddoc from source/botan/algo_base/buf_comp.d -->
Buffered Computation
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="BufferedComputation"></a>interface <u>BufferedComputation</u>;
</big></dt>
<dd>This class represents any kind of computation which uses an internal
 state, such as hash functions or MACs<br><br>

<dl><dt><big><a name="BufferedComputation.update"></a>final void <u>update</u>(in ubyte[] <i>input</i>);
</big></dt>
<dd>Add new <i>input</i> to process.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>input</i></td>
<td>the <i>input</i> to process as a ubyte array</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.update.2"></a>final void <u>update</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Add new <i>input</i> to process.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the <i>input</i> to process as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>of param in in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.update.3"></a>final void <u>update</u>(T, ALLOC)(auto ref const RefCounted!(Vector!(T, ALLOC)) <i>input</i>);
</big></dt>
<dd>Add new input to process.
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(T, ALLOC)) input</td>
<td>the input to process as a reference type</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.update.4"></a>final void <u>update</u>(T, ALLOC)(auto ref const Vector!(T, ALLOC) <i>input</i>);
</big></dt>
<dd>Add new input to process.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(T, ALLOC) input</td>
<td>the input to process as a </td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.updateBigEndian"></a>final void <u>updateBigEndian</u>(T)(in T <i>input</i>);
</big></dt>
<dd>Add an integer in big-endian order
<br><br>
<b>Params:</b><br>
<table><tr><td>T input</td>
<td>the value</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.update.5"></a>final void <u>update</u>(in string <i>str</i>);
</big></dt>
<dd>Add new input to process.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>The input to process as a string.</td></tr>
</table><br>
<b>Notes:</b><br>
Will be interpreted as a ubyte array based on the strings encoding.<br><br>

</dd>
<dt><big><a name="BufferedComputation.update.6"></a>final void <u>update</u>(ubyte <i>input</i>);
</big></dt>
<dd>Process a single ubyte.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>input</i></td>
<td>the ubyte to process</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.flushInto"></a>final void <u>flushInto</u>(ref ubyte[] <i>output</i>);
</big></dt>
<dd>Complete the computation and retrieve the final result.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>output</i></td>
<td>The ubyte array to be filled with the result.</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length outputLength()<br><br>

</dd>
<dt><big><a name="BufferedComputation.flushInto.2"></a>final void <u>flushInto</u>(ubyte* <i>output</i>);
</big></dt>
<dd>Complete the computation and retrieve the
 final result.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>The ubyte array to be filled with the result.</td></tr>
</table><br>
<b>Notes:</b><br>
Must be of length outputLength()<br><br>

</dd>
<dt><big><a name="BufferedComputation.finished"></a>final SecureVector!ubyte <u>finished</u>();
</big></dt>
<dd>Complete the computation and retrieve the final result.
<br><br>
<b>Returns:</b><br>
 holding the result<br><br>

</dd>
<dt><big><a name="BufferedComputation.process"></a>final SecureVector!ubyte <u>process</u>(in ubyte[] <i>input</i>);
</big></dt>
<dd>Update and finalize computation. Does the same as calling 
 and  consecutively.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte[] <i>input</i></td>
<td>the <i>input</i> to <u>process</u> as a ubyte array</td></tr>
</table><br>
<b>Returns:</b><br>
The result of the call to <br><br>

</dd>
<dt><big><a name="BufferedComputation.process.2"></a>final SecureVector!ubyte <u>process</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Update and finalize computation. Does the same as calling 
 and  consecutively.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the <i>input</i> to <u>process</u> as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array</td></tr>
</table><br>
<b>Returns:</b><br>
The result of the call to <br><br>

</dd>
<dt><big><a name="BufferedComputation.process.3"></a>final SecureVector!ubyte <u>process</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Update and finalize computation. Does the same as calling 
 and  consecutively.
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) input</td>
<td>the input to <u>process</u></td></tr>
</table><br>
<b>Returns:</b><br>
The result of the call to <br><br>

</dd>
<dt><big><a name="BufferedComputation.process.4"></a>final SecureVector!ubyte <u>process</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>);
</big></dt>
<dd>Update and finalize computation. Does the same as calling 
 and  consecutively.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>the input to <u>process</u></td></tr>
</table><br>
<b>Returns:</b><br>
The result of the call to <br><br>

</dd>
<dt><big><a name="BufferedComputation.process.5"></a>final SecureVector!ubyte <u>process</u>(in string <i>input</i>);
</big></dt>
<dd>Update and finalize computation. Does the same as calling 
 and  consecutively.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>the <i>input</i> to <u>process</u> as a string</td></tr>
</table><br>
<b>Returns:</b><br>
The result of the call to <br><br>

</dd>
<dt><big><a name="BufferedComputation.outputLength"></a>abstract const @property size_t <u>outputLength</u>();
</big></dt>
<dd><b>Returns:</b><br>
Length of the output of this function in bytes<br><br>

</dd>
<dt><big><a name="BufferedComputation.addData"></a>protected abstract void <u>addData</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Add more data to the computation
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>is an <i>input</i> buffer</td></tr>
<tr><td>size_t <i>length</i></td>
<td>is the <i>length</i> of <i>input</i> in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="BufferedComputation.finalResult"></a>protected abstract void <u>finalResult</u>(ubyte* <i>output</i>);
</big></dt>
<dd>Write the final <i>output</i> to out
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>An <i>output</i> buffer of size </td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
