<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.tls.session_manager</title>
        </head><body>
        <h1>botan.tls.session_manager</h1>
        <!-- Generated by Ddoc from source/botan/tls/session_manager.d -->
TLS Session Manager
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="TLSSessionManager"></a>interface <u>TLSSessionManager</u>;
</big></dt>
<dd><u>TLSSessionManager</u> is an interface to systems which can save
 session parameters for supporting session resumption.
<br><br>
Saving sessions is done on a best-effort basis; an implementation is
 allowed to drop sessions due to space constraints.
<br><br>

 Implementations should strive to be thread safe<br><br>

<dl><dt><big><a name="TLSSessionManager.loadFromSessionId"></a>abstract bool <u>loadFromSessionId</u>(ref const Vector!ubyte <i>session_id</i>, ref TLSSession <i>session</i>);
</big></dt>
<dd>Try to load a saved <i>session</i> (using <i>session</i> ID)
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!ubyte <i>session_id</i></td>
<td>the <i>session</i> identifier we are trying to resume</td></tr>
<tr><td>TLSSession <i>session</i></td>
<td>will be set to the saved <i>session</i> data (if found),
                or not modified if not found</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if <i>session</i> was modified<br><br>

</dd>
<dt><big><a name="TLSSessionManager.loadFromServerInfo"></a>abstract bool <u>loadFromServerInfo</u>(in TLSServerInformation <i>info</i>, ref TLSSession <i>session</i>);
</big></dt>
<dd>Try to load a saved <i>session</i> (using <i>info</i> about server)
<br><br>
<b>Params:</b><br>
<table><tr><td>TLSServerInformation <i>info</i></td>
<td>the information about the server</td></tr>
<tr><td>TLSSession <i>session</i></td>
<td>will be set to the saved <i>session</i> data (if found),
                or not modified if not found</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if <i>session</i> was modified<br><br>

</dd>
<dt><big><a name="TLSSessionManager.removeEntry"></a>abstract void <u>removeEntry</u>(ref const Vector!ubyte <i>session_id</i>);
</big></dt>
<dd>Remove this session id from the cache, if it exists<br><br>

</dd>
<dt><big><a name="TLSSessionManager.save"></a>abstract void <u>save</u>(ref const TLSSession <i>session</i>);
</big></dt>
<dd>Save a <i>session</i> on a best effort basis; the manager may not in
 fact be able to <u>save</u> the <i>session</i> for whatever reason; this is
 not an error. Caller cannot assume that calling <u>save</u> followed
 immediately by load_from_* will result in a successful lookup.
<br><br>
<b>Params:</b><br>
<table><tr><td>TLSSession <i>session</i></td>
<td>to <u>save</u></td></tr>
</table><br>

</dd>
<dt><big><a name="TLSSessionManager.sessionLifetime"></a>abstract const Duration <u>sessionLifetime</u>();
</big></dt>
<dd>Return the allowed lifetime of a session; beyond this time,
 sessions are not resumed. Returns 0 if unknown/no explicit
 expiration policy.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="TLSSessionManagerNoop"></a>class <u>TLSSessionManagerNoop</u>: <u>botan.tls.session_manager.TLSSessionManager</u>;
</big></dt>
<dd>An implementation of TLSSessionManager that does not save sessions at
 all, preventing session resumption.<br><br>

</dd>
<dt><big><a name="TLSSessionManagerInMemory"></a>class <u>TLSSessionManagerInMemory</u>: <u>botan.tls.session_manager.TLSSessionManager</u>;
</big></dt>
<dd>An implementation of TLSSessionManager that saves values in memory.<br><br>

<dl><dt><big><a name="TLSSessionManagerInMemory.this"></a>this(RandomNumberGenerator <i>rng</i>, size_t <i>max_sessions</i> = 1000, Duration <i>session_lifetime</i> = 7200.seconds);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>a random number generator</td></tr>
<tr><td>size_t <i>max_sessions</i></td>
<td>a hint on the maximum number of sessions
          to keep in memory at any one time. (If zero, don't cap)</td></tr>
<tr><td>Duration <i>session_lifetime</i></td>
<td>sessions are expired after this duration has elapsed from initial handshake.</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2011 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
