<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.utils.parsing</title>
        </head><body>
        <h1>botan.utils.parsing</h1>
        <!-- Generated by Ddoc from source/botan/utils/parsing.d -->
Various string utils and <u>parsing</u> functions
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="parseAlgorithmName"></a>Vector!string <u>parseAlgorithmName</u>(in string <i>scan_name</i>);
</big></dt>
<dd>Parse a SCAN-style algorithm name
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>scan_name</i></td>
<td>the name</td></tr>
</table><br>
<b>Returns:</b><br>
the name components<br><br>

</dd>
<dt><big><a name="splitter"></a>Vector!string <u>splitter</u>(in string <i>str</i>, char <i>delim</i>);
</big></dt>
<dd>Split a string
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the input string</td></tr>
<tr><td>char <i>delim</i></td>
<td>the delimitor</td></tr>
</table><br>
<b>Returns:</b><br>
string split by <i>delim</i><br><br>

</dd>
<dt><big><a name="splitOnPred"></a>Vector!string <u>splitOnPred</u>(in string <i>str</i>, bool delegate(char) <i>pred</i>);
</big></dt>
<dd>Split a string on a character predicate
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the input string</td></tr>
<tr><td>bool delegate(char) <i>pred</i></td>
<td>the predicate that returns <b>true</b> to split</td></tr>
</table><br>

</dd>
<dt><big><a name="eraseChars"></a>string <u>eraseChars</u>(in string <i>str</i>, in char[] <i>chars</i>);
</big></dt>
<dd>Erase characters from a string<br><br>

</dd>
<dt><big><a name="replaceChar"></a>string <u>replaceChar</u>(in string <i>str</i>, in char <i>from_char</i>, in char <i>to_char</i>);
</big></dt>
<dd>Replace a character in a string
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the input string</td></tr>
<tr><td>char <i>from_char</i></td>
<td>the character to replace</td></tr>
<tr><td>char <i>to_char</i></td>
<td>the character to replace it with</td></tr>
</table><br>
<b>Returns:</b><br>
<i>str</i> with all instances of <i>from_char</i> replaced by <i>to_char</i><br><br>

</dd>
<dt><big><a name="replaceChars"></a>string <u>replaceChars</u>(in string <i>str</i>, in char[] <i>chars</i>, in char <i>to_char</i>);
</big></dt>
<dd>Replace a character in a string
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the input string</td></tr>
<tr><td>char[] <i>chars</i></td>
<td>the characters to replace</td></tr>
<tr><td>char <i>to_char</i></td>
<td>the character to replace it with</td></tr>
</table><br>
<b>Returns:</b><br>
<i>str</i> with all instances of <i>chars</i> replaced by <i>to_char</i><br><br>

</dd>
<dt><big><a name="stringJoin"></a>string <u>stringJoin</u>(ref const Vector!string <i>strs</i>, char <i>delim</i>);
</big></dt>
<dd>Join a string
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!string <i>strs</i></td>
<td>strings to join</td></tr>
<tr><td>char <i>delim</i></td>
<td>the delimitor</td></tr>
</table><br>
<b>Returns:</b><br>
string joined by <i>delim</i><br><br>

</dd>
<dt><big><a name="parseAsn1Oid"></a>Vector!uint <u>parseAsn1Oid</u>(in string <i>oid</i>);
</big></dt>
<dd>Parse an ASN.1 OID
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>oid</i></td>
<td>the OID in string form</td></tr>
</table><br>
<b>Returns:</b><br>
OID components<br><br>

</dd>
<dt><big><a name="x500NameCmp"></a>bool <u>x500NameCmp</u>(in string <i>name1</i>, in string <i>name2</i>);
</big></dt>
<dd>Compare two names using the X.509 comparison algorithm
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>name1</i></td>
<td>the first name</td></tr>
<tr><td>string <i>name2</i></td>
<td>the second name</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if <i>name1</i> is the same as <i>name2</i> by the X.509 comparison rules<br><br>

</dd>
<dt><big><a name="stringToIpv4"></a>uint <u>stringToIpv4</u>(in string <i>str</i>);
</big></dt>
<dd>Convert a string representation of an IPv4 address to a number
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the string representation</td></tr>
</table><br>
<b>Returns:</b><br>
integer IPv4 address<br><br>

</dd>
<dt><big><a name="ipv4ToString"></a>string <u>ipv4ToString</u>(uint <i>ip</i>);
</big></dt>
<dd>Convert an IPv4 address to a string
<br><br>
<b>Params:</b><br>
<table><tr><td>uint <i>ip</i></td>
<td>the IPv4 address to convert</td></tr>
</table><br>
<b>Returns:</b><br>
string representation of the IPv4 address<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007,2013 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
