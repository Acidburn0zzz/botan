<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.codec.hex</title>
        </head><body>
        <h1>botan.codec.hex</h1>
        <!-- Generated by Ddoc from source/botan/codec/hex.d -->
Hex Encoding and Decoding
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="hexEncode"></a>void <u>hexEncode</u>(char* <i>output</i>, const(ubyte)* <i>input</i>, size_t <i>input_length</i>, bool <i>uppercase</i> = true);
</big></dt>
<dd>Perform hex encoding
<br><br>
<b>Params:</b><br>
<table><tr><td>char* <i>output</i></td>
<td>an array of at least <i>input_length</i>*2 bytes</td></tr>
<tr><td>const(ubyte)* <i>input</i></td>
<td>is some binary data</td></tr>
<tr><td>size_t <i>input_length</i></td>
<td>length of <i>input</i> in bytes</td></tr>
<tr><td>bool <i>uppercase</i></td>
<td>should <i>output</i> be upper or lower case?</td></tr>
</table><br>

</dd>
<dt><big><a name="hexEncode.2"></a>string <u>hexEncode</u>(const(ubyte)* <i>input</i>, size_t <i>input_length</i>, bool <i>uppercase</i> = true);
</big></dt>
<dd>Perform hex encoding
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>some <i>input</i></td></tr>
<tr><td>size_t <i>input_length</i></td>
<td>length of <i>input</i> in bytes</td></tr>
<tr><td>bool <i>uppercase</i></td>
<td>should output be upper or lower case?</td></tr>
</table><br>
<b>Returns:</b><br>
hexadecimal representation of <i>input</i><br><br>

</dd>
<dt><big><a name="hexEncode.3"></a>string <u>hexEncode</u>(Alloc)(auto ref const Vector!(ubyte, Alloc) <i>input</i>, bool <i>uppercase</i> = true);
<br>string <u>hexEncode</u>(Alloc)(auto ref const RefCounted!(Vector!(ubyte, Alloc), Alloc) <i>input</i>, bool <i>uppercase</i> = true);
</big></dt>
<dd>Perform hex encoding
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) input</td>
<td>some input</td></tr>
<tr><td>bool uppercase</td>
<td>should output be upper or lower case?</td></tr>
</table><br>
<b>Returns:</b><br>
hexadecimal representation of input<br><br>

</dd>
<dt><big><a name="hexDecode"></a>size_t <u>hexDecode</u>(ubyte* <i>output</i>, const(char)* <i>input</i>, size_t <i>input_length</i>, ref size_t <i>input_consumed</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>an array of at least <i>input_length</i>/2 bytes</td></tr>
<tr><td>const(char)* <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>size_t <i>input_length</i></td>
<td>length of <i>input</i> in bytes</td></tr>
<tr><td>size_t <i>input_consumed</i></td>
<td>is an <i>output</i> parameter which says how many
          bytes of <i>input</i> were actually consumed. If less than
          <i>input_length</i>, then the range <i>input</i>[consumed:length]
          should be passed in later along with more <i>input</i>.</td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes written to <i>output</i><br><br>

</dd>
<dt><big><a name="hexDecode.2"></a>size_t <u>hexDecode</u>(ubyte* <i>output</i>, const(char)* <i>input</i>, size_t <i>input_length</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>an array of at least <i>input_length</i>/2 bytes</td></tr>
<tr><td>const(char)* <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>size_t <i>input_length</i></td>
<td>length of <i>input</i> in bytes</td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes written to <i>output</i><br><br>

</dd>
<dt><big><a name="hexDecode.3"></a>size_t <u>hexDecode</u>(ubyte* <i>output</i>, in string <i>input</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>an array of at least input_length/2 bytes</td></tr>
<tr><td>string <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes written to <i>output</i><br><br>

</dd>
<dt><big><a name="hexDecode.4"></a>Vector!ubyte <u>hexDecode</u>(string <i>input</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
decoded hex output<br><br>

</dd>
<dt><big><a name="hexDecode.5"></a>Vector!ubyte <u>hexDecode</u>(ref const Vector!ubyte <i>input</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!ubyte <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
decoded hex output<br><br>

</dd>
<dt><big><a name="hexDecodeLocked"></a>SecureVector!ubyte <u>hexDecodeLocked</u>(const(char)* <i>input</i>, size_t <i>input_length</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>const(char)* <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>size_t <i>input_length</i></td>
<td>the length of <i>input</i> in bytes</td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
decoded hex output<br><br>

</dd>
<dt><big><a name="hexDecodeLocked.2"></a>SecureVector!ubyte <u>hexDecodeLocked</u>(in string <i>input</i>, bool <i>ignore_ws</i> = true);
</big></dt>
<dd>Perform hex decoding
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>some hex <i>input</i></td></tr>
<tr><td>bool <i>ignore_ws</i></td>
<td>ignore whitespace on <i>input</i>; if <b>false</b>, throw new an
                         exception if whitespace is encountered</td></tr>
</table><br>
<b>Returns:</b><br>
decoded hex output<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2010 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
