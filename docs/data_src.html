<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.filters.data_src</title>
        </head><body>
        <h1>botan.filters.data_src</h1>
        <!-- Generated by Ddoc from source/botan/filters/data_src.d -->
DataSource
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="DataSourceImpl"></a>interface <u>DataSourceImpl</u>;
</big></dt>
<dd>This class represents an abstract data source object.<br><br>

<dl><dt><big><a name="DataSourceImpl.read"></a>abstract size_t <u>read</u>(ubyte* <i>output</i>, size_t <i>length</i>);
</big></dt>
<dd>Read from the source. Moves the internal offset so that every
 call to <u>read</u> will return a new portion of the source.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>the ubyte array to write the result to</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array out</td></tr>
</table><br>
<b>Returns:</b><br>
<i>length</i> in bytes that was actually <u>read</u> and put
 into out<br><br>

</dd>
<dt><big><a name="DataSourceImpl.peek"></a>abstract const size_t <u>peek</u>(ubyte* <i>output</i>, size_t <i>length</i>, size_t <i>peek_offset</i>);
</big></dt>
<dd>Read from the source but do not modify the internal
 offset. Consecutive calls to <u>peek</u>() will return portions of
 the source starting at the same position.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>the ubyte array to write the <i>output</i> to</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array out</td></tr>
<tr><td>size_t <i>peek_offset</i></td>
<td>the offset into the stream to read at</td></tr>
</table><br>
<b>Returns:</b><br>
<i>length</i> in bytes that was actually read and put
 into out<br><br>

</dd>
<dt><big><a name="DataSourceImpl.endOfData"></a>abstract const bool <u>endOfData</u>();
</big></dt>
<dd>Test whether the source still has data that can be read.
<br><br>
<b>Returns:</b><br>
<b>true</b> if there is still data to read, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="DataSourceImpl.id"></a>abstract const string <u>id</u>();
</big></dt>
<dd>return the <u>id</u> of this data source
<br><br>
<b>Returns:</b><br>
string representing the <u>id</u> of this data source<br><br>

</dd>
<dt><big><a name="DataSourceImpl.readByte"></a>final size_t <u>readByte</u>(ref ubyte <i>output</i>);
</big></dt>
<dd>Read one ubyte.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>the ubyte to read to</td></tr>
</table><br>
<b>Returns:</b><br>
length in bytes that was actually read and put
 into out<br><br>

</dd>
<dt><big><a name="DataSourceImpl.peekByte"></a>final const size_t <u>peekByte</u>(ref ubyte <i>output</i>);
</big></dt>
<dd>Peek at one ubyte.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>output</i></td>
<td>an <i>output</i> ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
length in bytes that was actually read and put
 into out<br><br>

</dd>
<dt><big><a name="DataSourceImpl.discardNext"></a>final size_t <u>discardNext</u>(size_t <i>n</i>);
</big></dt>
<dd>Discard the next N bytes of the data
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>the number of bytes to discard</td></tr>
</table><br>
<b>Returns:</b><br>
number of bytes actually discarded<br><br>

</dd>
<dt><big><a name="DataSourceImpl.getBytesRead"></a>abstract const size_t <u>getBytesRead</u>();
</big></dt>
<dd><b>Returns:</b><br>
number of bytes read so far.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="DataSourceMemoryImpl"></a>class <u>DataSourceMemoryImpl</u>: <u>botan.filters.data_src.DataSourceImpl</u>;
</big></dt>
<dd>This class represents a Memory-Based DataSource<br><br>

<dl><dt><big><a name="DataSourceMemoryImpl.this"></a>this(in string <i>input</i>);
</big></dt>
<dd>Construct a memory source that reads from a string
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>input</i></td>
<td>the string to read from</td></tr>
</table><br>

</dd>
<dt><big><a name="DataSourceMemoryImpl.this.2"></a>this(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Construct a memory source that reads from a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the ubyte array to read from</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the ubyte array</td></tr>
</table><br>

</dd>
<dt><big><a name="DataSourceMemoryImpl.this.3"></a>this(T, ALLOC)(auto ref const RefCounted!(Vector!(T, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Construct a memory source that reads from a referenced vector
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(T, ALLOC), ALLOC) input</td>
<td>the MemoryRegion to read from</td></tr>
</table><br>

</dd>
<dt><big><a name="DataSourceMemoryImpl.this.4"></a>this(T, ALLOC)(auto ref const Vector!(T, ALLOC) <i>input</i>);
</big></dt>
<dd>Construct a memory source that reads from a vector
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(T, ALLOC) input</td>
<td>the MemoryRegion to read from</td></tr>
</table><br>

</dd>
<dt><big><a name="DataSourceMemoryImpl.this.5"></a>this(T, ALLOC)(const Vector!(T, ALLOC)* <i>input</i>);
</big></dt>
<dd>Construct a memory source that reads from a vector*
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(T, ALLOC)* input</td>
<td>the MemoryRegion to read from</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="DataSourceStreamImpl"></a>class <u>DataSourceStreamImpl</u>: <u>botan.filters.data_src.DataSourceImpl</u>;
</big></dt>
<dd>This class represents a Stream-Based DataSource.<br><br>

<dl><dt><big><a name="DataSourceStreamImpl.this"></a>this(in string <i>path</i>, bool <i>use_binary</i> = false);
</big></dt>
<dd>Construct a Stream-Based DataSource from file
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>path</i></td>
<td>the name of the file</td></tr>
<tr><td>bool <i>use_binary</i></td>
<td>whether to treat the file as binary or not</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon
     2012 Markus Wanner

</small>
        </body></html>
