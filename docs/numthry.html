<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.math.numbertheory.numthry</title>
        </head><body>
        <h1>botan.math.numbertheory.numthry</h1>
        <!-- Generated by Ddoc from source/botan/math/numbertheory/numthry.d -->
Number Theory Functions
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="mulAdd"></a>BigInt <u>mulAdd</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>b</i>, auto ref const BigInt <i>c</i>);
</big></dt>
<dd>Fused multiply-add
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>an integer</td></tr>
<tr><td>BigInt b</td>
<td>an integer</td></tr>
<tr><td>BigInt c</td>
<td>an integer</td></tr>
</table><br>
<b>Returns:</b><br>
(a*b)+c<br><br>

</dd>
<dt><big><a name="subMul"></a>BigInt <u>subMul</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>b</i>, auto ref const BigInt <i>c</i>);
</big></dt>
<dd>Fused subtract-multiply
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>an integer</td></tr>
<tr><td>BigInt b</td>
<td>an integer</td></tr>
<tr><td>BigInt c</td>
<td>an integer</td></tr>
</table><br>
<b>Returns:</b><br>
(a-b)*c<br><br>

</dd>
<dt><big><a name="abs"></a>BigInt <u>abs</u>()(auto ref const BigInt <i>n</i>);
</big></dt>
<dd>Return the absolute value
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>an integer</td></tr>
</table><br>
<b>Returns:</b><br>
absolute value of n<br><br>

</dd>
<dt><big><a name="gcd"></a>BigInt <u>gcd</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>b</i>);
</big></dt>
<dd>Compute the greatest common divisor
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>positive integer x</td></tr>
<tr><td>BigInt b</td>
<td>positive integer y</td></tr>
</table><br>
<b>Returns:</b><br>
<u>gcd</u>(x,y)<br><br>

</dd>
<dt><big><a name="lcm"></a>BigInt <u>lcm</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>b</i>);
</big></dt>
<dd>Least common multiple
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>a positive integer x</td></tr>
<tr><td>BigInt b</td>
<td>a positive integer y</td></tr>
</table><br>
<b>Returns:</b><br>
z, smallest integer such that z % x == 0 and z % y == 0<br><br>

</dd>
<dt><big><a name="square"></a>BigInt <u>square</u>()(auto ref const BigInt <i>x</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>BigInt x</td>
<td>an integer</td></tr>
</table><br>
<b>Returns:</b><br>
(x*x)<br><br>

</dd>
<dt><big><a name="inverseMod"></a>BigInt <u>inverseMod</u>()(auto ref const BigInt <i>n</i>, auto ref const BigInt <i>mod</i>);
</big></dt>
<dd>Modular inversion
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>a positive integer x</td></tr>
<tr><td>BigInt mod</td>
<td>a positive integer modulus</td></tr>
</table><br>
<b>Returns:</b><br>
y st (x*y) % modulus == 1<br><br>

</dd>
<dt><big><a name="jacobi"></a>int <u>jacobi</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>n</i>);
</big></dt>
<dd>Compute the Jacobi symbol. If n is prime, this is equivalent
 to the Legendre symbol.
 @see http://mathworld.wolfram.com/JacobiSymbol.html
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>is a non-negative integer</td></tr>
<tr><td>BigInt n</td>
<td>is an odd integer &gt; 1</td></tr>
</table><br>
<b>Returns:</b><br>
(n / m)<br><br>

</dd>
<dt><big><a name="powerMod"></a>BigInt <u>powerMod</u>()(auto ref const BigInt <i>base</i>, auto ref const BigInt <i>exp</i>, auto ref const BigInt <i>mod</i>);
</big></dt>
<dd>Modular exponentation
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt base</td>
<td>an integer base b</td></tr>
<tr><td>BigInt exp</td>
<td>a positive exponent x</td></tr>
<tr><td>BigInt mod</td>
<td>a positive modulus m</td></tr>
</table><br>
<b>Returns:</b><br>
(b^x) % m<br><br>

</dd>
<dt><big><a name="ressol"></a>BigInt <u>ressol</u>()(auto ref const BigInt <i>a</i>, auto ref const BigInt <i>p</i>);
</big></dt>
<dd>Compute the square root of x modulo a prime using the
 Shanks-Tonnelli algorithm
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt a</td>
<td>the input x</td></tr>
<tr><td>BigInt p</td>
<td>the prime p</td></tr>
</table><br>
<b>Returns:</b><br>
y such that (y*y)%p == x, or -1 if no such integer<br><br>

</dd>
<dt><big><a name="lowZeroBits"></a>size_t <u>lowZeroBits</u>()(auto ref const BigInt <i>n</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>a positive integer x</td></tr>
</table><br>
<b>Returns:</b><br>
count of the zero bits in x, or, equivalently, the largest
            value of n such that 2^n divides x evenly. Returns zero if
            n is less than or equal to zero.<br><br>

</dd>
<dt><big><a name="isPrime"></a>bool <u>isPrime</u>()(auto ref const BigInt <i>n</i>, RandomNumberGenerator <i>rng</i>, size_t <i>prob</i> = 56, bool <i>is_random</i> = false);
</big></dt>
<dd>Check for primality using Miller-Rabin
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>a positive integer to test for primality</td></tr>
<tr><td>RandomNumberGenerator rng</td>
<td>a random number generator</td></tr>
<tr><td>size_t prob</td>
<td>chance of <b>false</b> positive is bounded by 1/2**prob</td></tr>
<tr><td>bool is_random</td>
<td><b>true</b> if n was randomly chosen by us</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if all primality tests passed, otherwise <b>false</b><br><br>

</dd>
<dt><big><a name="randomPrime"></a>BigInt <u>randomPrime</u>()(RandomNumberGenerator <i>rng</i>, size_t <i>bits</i>, ref const BigInt <i>coprime</i>, size_t <i>equiv</i> = 1, size_t <i>modulo</i> = 2);
<br>BigInt <u>randomPrime</u>()(RandomNumberGenerator <i>rng</i>, size_t <i>bits</i>, const BigInt <i>coprime</i> = 1, size_t <i>equiv</i> = 1, size_t <i>modulo</i> = 2);
</big></dt>
<dd>Randomly generate a prime
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator rng</td>
<td>a random number generator</td></tr>
<tr><td>size_t bits</td>
<td>how large the resulting prime should be in bits</td></tr>
<tr><td>BigInt coprime</td>
<td>a positive integer the result should be coprime to</td></tr>
<tr><td>size_t equiv</td>
<td>a non-negative number that the result should be
                    equivalent to modulo equiv_mod</td></tr>
<tr><td>size_t modulo</td>
<td>the modulus equiv should be checked against</td></tr>
</table><br>
<b>Returns:</b><br>
random prime with the specified criteria<br><br>

</dd>
<dt><big><a name="randomSafePrime"></a>BigInt <u>randomSafePrime</u>(RandomNumberGenerator <i>rng</i>, size_t <i>bits</i>);
</big></dt>
<dd>Return a random 'safe' prime, of the form p=2*q+1 with q prime
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>a random number generator</td></tr>
<tr><td>size_t <i>bits</i></td>
<td>is how long the resulting prime should be</td></tr>
</table><br>
<b>Returns:</b><br>
prime randomly chosen from safe primes of length <i>bits</i><br><br>

</dd>
<dt><big><a name="generateDsaPrimes"></a>Vector!ubyte <u>generateDsaPrimes</u>(RandomNumberGenerator <i>rng</i>, AlgorithmFactory <i>af</i>, ref BigInt <i>p_out</i>, ref BigInt <i>q_out</i>, size_t <i>pbits</i>, size_t <i>qbits</i>);
</big></dt>
<dd>Generate DSA parameters using the FIPS 186 kosherizer
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>a random number generator</td></tr>
<tr><td>AlgorithmFactory <i>af</i></td>
<td>an algorithm factory</td></tr>
<tr><td>BigInt <i>p_out</i></td>
<td>where the prime p will be stored</td></tr>
<tr><td>BigInt <i>q_out</i></td>
<td>where the prime q will be stored</td></tr>
<tr><td>size_t <i>pbits</i></td>
<td>how long p will be in bits</td></tr>
<tr><td>size_t <i>qbits</i></td>
<td>how long q will be in bits</td></tr>
</table><br>
<b>Returns:</b><br>
random seed used to generate this parameter set<br><br>

</dd>
<dt><big><a name="generateDsaPrimes.2"></a>bool <u>generateDsaPrimes</u>()(RandomNumberGenerator <i>rng</i>, AlgorithmFactory <i>af</i>, ref BigInt <i>p_out</i>, ref BigInt <i>q_out</i>, size_t <i>pbits</i>, size_t <i>qbits</i>, auto ref const Vector!ubyte <i>seed_c</i>);
</big></dt>
<dd>Generate DSA parameters using the FIPS 186 kosherizer
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator rng</td>
<td>a random number generator</td></tr>
<tr><td>AlgorithmFactory af</td>
<td>an algorithm factory</td></tr>
<tr><td>BigInt p_out</td>
<td>where the prime p will be stored</td></tr>
<tr><td>BigInt q_out</td>
<td>where the prime q will be stored</td></tr>
<tr><td>size_t pbits</td>
<td>how long p will be in bits</td></tr>
<tr><td>size_t qbits</td>
<td>how long q will be in bits</td></tr>
<tr><td>Vector!ubyte seed_c</td>
<td>the seed used to generate the parameters</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if seed generated a valid DSA parameter set, otherwise
             <b>false</b>. p_out and q_out are only valid if <b>true</b> was returned.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
