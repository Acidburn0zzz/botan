<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.entropy.entropy_src</title>
        </head><body>
        <h1>botan.entropy.entropy_src</h1>
        <!-- Generated by Ddoc from source/botan/entropy/entropy_src.d -->
EntropySource
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="EntropyAccumulator"></a>struct <u>EntropyAccumulator</u>;
</big></dt>
<dd>Class used to accumulate the poll results of EntropySources<br><br>

<dl><dt><big><a name="EntropyAccumulator.this"></a>this(bool delegate(const(ubyte)*, size_t len, double) <i>accum</i>);
</big></dt>
<dd>Initialize an EntropyAccumulator
<br><br>
<b>Params:</b><br>
<table><tr><td>bool delegate(const(ubyte)*, size_t len, double) <i>accum</i></td>
<td>a delegate to send the bytes and entropy value</td></tr>
</table><br>

</dd>
<dt><big><a name="EntropyAccumulator.getIoBuffer"></a>ref SecureVector!ubyte <u>getIoBuffer</u>(size_t <i>size</i>);
</big></dt>
<dd>Get a cached I/O buffer (purely for minimizing allocation
 overhead to polls)
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>size</i></td>
<td>requested <i>size</i> for the I/O buffer</td></tr>
</table><br>
<b>Returns:</b><br>
cached I/O buffer for repeated polls<br><br>

</dd>
<dt><big><a name="EntropyAccumulator.pollingGoalAchieved"></a>const bool <u>pollingGoalAchieved</u>();
</big></dt>
<dd><b>Returns:</b><br>
if our polling goal has been achieved<br><br>

</dd>
<dt><big><a name="EntropyAccumulator.add"></a>void <u>add</u>(const void* <i>bytes</i>, size_t <i>length</i>, double <i>entropy_bits_per_byte</i>);
</big></dt>
<dd>Add entropy to the accumulator
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>bytes</i></td>
<td>the input <i>bytes</i></td></tr>
<tr><td>size_t <i>length</i></td>
<td>specifies how many <i>bytes</i> the input is</td></tr>
<tr><td>double <i>entropy_bits_per_byte</i></td>
<td>is a best guess at how much
 entropy per ubyte is in this input</td></tr>
</table><br>

</dd>
<dt><big><a name="EntropyAccumulator.add.2"></a>void <u>add</u>(T)(in T <i>v</i>, double <i>entropy_bits_per_byte</i>);
</big></dt>
<dd>Add entropy to the accumulator
<br><br>
<b>Params:</b><br>
<table><tr><td>T v</td>
<td>is some value</td></tr>
<tr><td>double entropy_bits_per_byte</td>
<td>is a best guess at how much
 entropy per ubyte is in this input</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="EntropySource"></a>interface <u>EntropySource</u>;
</big></dt>
<dd>Abstract interface to a source of entropy<br><br>

<dl><dt><big><a name="EntropySource.name"></a>abstract const @property string <u>name</u>();
</big></dt>
<dd><b>Returns:</b><br>
<u>name</u> identifying this entropy source<br><br>

</dd>
<dt><big><a name="EntropySource.poll"></a>abstract void <u>poll</u>(ref EntropyAccumulator <i>accum</i>);
</big></dt>
<dd>Perform an entropy gathering <u>poll</u>
<br><br>
<b>Params:</b><br>
<table><tr><td>EntropyAccumulator <i>accum</i></td>
<td>is an accumulator object that will be given entropy</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 2008-2009,2014 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
