<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.kdf.kdf</title>
        </head><body>
        <h1>botan.kdf.kdf</h1>
        <!-- Generated by Ddoc from source/botan/kdf/kdf.d -->
Key Derivation Function interfaces
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="KDF"></a>abstract class <u>KDF</u>;
</big></dt>
<dd>Key Derivation Function<br><br>

<dl><dt><big><a name="KDF.deriveKey"></a>const SecureVector!ubyte <u>deriveKey</u>()(size_t <i>key_len</i>, auto ref const SecureVector!ubyte <i>secret</i>, in string <i>salt</i> = "");
</big></dt>
<dd>Derive a key
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t key_len</td>
<td>the desired output length in bytes</td></tr>
<tr><td>SecureVector!ubyte secret</td>
<td>the secret input</td></tr>
<tr><td>string salt</td>
<td>a diversifier</td></tr>
</table><br>

</dd>
<dt><big><a name="KDF.deriveKey.2"></a>const SecureVector!ubyte <u>deriveKey</u>(Alloc)(size_t <i>key_len</i>, auto ref const SecureVector!ubyte <i>secret</i>, auto ref const Vector!(ubyte, Alloc) <i>salt</i>);
</big></dt>
<dd>Derive a key
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t key_len</td>
<td>the desired output length in bytes</td></tr>
<tr><td>SecureVector!ubyte secret</td>
<td>the secret input</td></tr>
<tr><td>Vector!(ubyte, Alloc) salt</td>
<td>a diversifier</td></tr>
</table><br>

</dd>
<dt><big><a name="KDF.deriveKey.3"></a>const SecureVector!ubyte <u>deriveKey</u>()(size_t <i>key_len</i>, auto ref const SecureVector!ubyte <i>secret</i>, const(ubyte)* <i>salt</i>, size_t <i>salt_len</i>);
</big></dt>
<dd>Derive a key
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t key_len</td>
<td>the desired output length in bytes</td></tr>
<tr><td>SecureVector!ubyte secret</td>
<td>the secret input</td></tr>
<tr><td>const(ubyte)* salt</td>
<td>a diversifier</td></tr>
<tr><td>size_t salt_len</td>
<td>size of salt in bytes</td></tr>
</table><br>

</dd>
<dt><big><a name="KDF.deriveKey.4"></a>const SecureVector!ubyte <u>deriveKey</u>(size_t <i>key_len</i>, const(ubyte)* <i>secret</i>, size_t <i>secret_len</i>, in string <i>salt</i> = "");
</big></dt>
<dd>Derive a key
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>key_len</i></td>
<td>the desired output length in bytes</td></tr>
<tr><td>const(ubyte)* <i>secret</i></td>
<td>the <i>secret</i> input</td></tr>
<tr><td>size_t <i>secret_len</i></td>
<td>size of <i>secret</i> in bytes</td></tr>
<tr><td>string <i>salt</i></td>
<td>a diversifier</td></tr>
</table><br>

</dd>
<dt><big><a name="KDF.deriveKey.5"></a>const SecureVector!ubyte <u>deriveKey</u>(size_t <i>key_len</i>, const(ubyte)* <i>secret</i>, size_t <i>secret_len</i>, const(ubyte)* <i>salt</i>, size_t <i>salt_len</i>);
</big></dt>
<dd>Derive a key
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>key_len</i></td>
<td>the desired output length in bytes</td></tr>
<tr><td>const(ubyte)* <i>secret</i></td>
<td>the <i>secret</i> input</td></tr>
<tr><td>size_t <i>secret_len</i></td>
<td>size of <i>secret</i> in bytes</td></tr>
<tr><td>const(ubyte)* <i>salt</i></td>
<td>a diversifier</td></tr>
<tr><td>size_t <i>salt_len</i></td>
<td>size of <i>salt</i> in bytes</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="getKdf"></a>KDF <u>getKdf</u>(in string <i>algo_spec</i>);
</big></dt>
<dd>Factory method for KDF (key derivation function)
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>algo_spec</i></td>
<td>the name of the KDF to create</td></tr>
</table><br>
<b>Returns:</b><br>
pointer to newly allocated object of that type<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2007 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
