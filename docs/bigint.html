<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.math.bigint.bigint</title>
        </head><body>
        <h1>botan.math.bigint.bigint</h1>
        <!-- Generated by Ddoc from source/botan/math/bigint/bigint.d -->
BigInt
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="BigInt"></a>struct <u>BigInt</u>;
</big></dt>
<dd>Arbitrary precision integer<br><br>

<dl><dt><big><a name="BigInt.DivideByZero"></a>class <u>DivideByZero</u>: <u>object.Exception</u>;
</big></dt>
<dd><u>DivideByZero</u> Exception<br><br>

</dd>
<dt><big><a name="BigInt.this"></a>this(T)(T <i>n</i>) if (isNumeric!T);
</big></dt>
<dd>Create BigInt from any integer
<br><br>
<b>Params:</b><br>
<table><tr><td>T n</td>
<td>initial value of this BigInt</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opAssign"></a>ref BigInt <u>opAssign</u>(size_t <i>other</i>);
</big></dt>
<dd>Move constructor<br><br>

</dd>
<dt><big><a name="BigInt.this.2"></a>this(in string <i>str</i>);
</big></dt>
<dd>Create BigInt from a string. If the string starts with 0x the
 rest of the string will be interpreted as hexadecimal digits.
 Otherwise, it will be interpreted as a decimal number.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>str</i></td>
<td>the string to parse for an integer value</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.this.3"></a>this(const(ubyte)* <i>input</i>, size_t <i>length</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Create a BigInt from an integer in a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the ubyte array holding the value</td></tr>
<tr><td>size_t <i>length</i></td>
<td>size of buf</td></tr>
<tr><td>Base <i>base</i></td>
<td>is the number <i>base</i> of the integer in buf</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.this.4"></a>this(RandomNumberGenerator <i>rng</i>, size_t <i>bits</i>);
</big></dt>
<dd>Create a random BigInt of the specified size
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>random number generator</td></tr>
<tr><td>size_t <i>bits</i></td>
<td>size in <i>bits</i></td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.this.5"></a>this(Sign <i>s</i>, size_t <i>size</i>);
</big></dt>
<dd>Create BigInt of specified <i>size</i>, all zeros
<br><br>
<b>Params:</b><br>
<table><tr><td>Sign <i>s</i></td>
<td>the sign</td></tr>
<tr><td>size_t <i>size</i></td>
<td>of the internal register in words</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.this.6"></a>this()(auto ref BigInt <i>other</i>);
</big></dt>
<dd>Move constructor<br><br>

</dd>
<dt><big><a name="BigInt.opAssign.2"></a>void <u>opAssign</u>()(auto ref BigInt <i>other</i>);
</big></dt>
<dd>Move assignment<br><br>

</dd>
<dt><big><a name="BigInt.swap"></a>void <u>swap</u>()(auto ref BigInt <i>other</i>);
</big></dt>
<dd>Copy assignment
<br><br>
Swap this value with another
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt other</td>
<td>BigInt to <u>swap</u> values with</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign"></a>void <u>opOpAssign</u>(string op)(auto ref const BigInt <i>y</i>) if (op == "+");
</big></dt>
<dd>+= operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt y</td>
<td>the BigInt to add to this</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.2"></a>void <u>opOpAssign</u>(string op)(auto ref const BigInt <i>y</i>) if (op == "-");
</big></dt>
<dd> -= operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt y</td>
<td>the BigInt to subtract from this</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.3"></a>void <u>opOpAssign</u>(string op)(ref const BigInt <i>y</i>) if (op == "*");
</big></dt>
<dd>*= operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt y</td>
<td>the BigInt to multiply with this</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.4"></a>void <u>opOpAssign</u>(string op)(auto ref const BigInt <i>y</i>) if (op == "/");
</big></dt>
<dd>/= operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt y</td>
<td>the BigInt to divide this by</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.5"></a>void <u>opOpAssign</u>(string op)(auto ref const BigInt <i>mod</i>) if (op == "%");
</big></dt>
<dd>Modulo operator
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt mod</td>
<td>the modulus to reduce this by</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.6"></a>void <u>opOpAssign</u>(string op)(word <i>mod</i>) if (op == "%");
</big></dt>
<dd>Modulo operator
<br><br>
<b>Params:</b><br>
<table><tr><td>word mod</td>
<td>the modulus (word) to reduce this by</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.7"></a>void <u>opOpAssign</u>(string op)(size_t <i>shift</i>) if (op == "&lt;&lt;");
</big></dt>
<dd>Left shift operator
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t shift</td>
<td>the number of bits to shift this left by</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opOpAssign.8"></a>void <u>opOpAssign</u>(string op)(size_t <i>shift</i>) if (op == "&gt;&gt;");
</big></dt>
<dd>Right shift operator
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t shift</td>
<td>the number of bits to shift this right by</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.opUnary"></a>ref BigInt <u>opUnary</u>(string op)() if (op == "++");
</big></dt>
<dd>Increment operator<br><br>

</dd>
<dt><big><a name="BigInt.opUnary.2"></a>ref BigInt <u>opUnary</u>(string op)() if (op == "--");
</big></dt>
<dd>Decrement operator<br><br>

</dd>
<dt><big><a name="BigInt.opUnary.3"></a>const BigInt <u>opUnary</u>(string op)() if (op == "-");
</big></dt>
<dd>Unary negation operator
<br><br>
<b>Returns:</b><br>
negative this<br><br>

</dd>
<dt><big><a name="BigInt.opCast"></a>const T <u>opCast</u>(T : bool)();
</big></dt>
<dd>bool cast
<br><br>
<b>Returns:</b><br>
<b>true</b> iff this is not zero, otherwise <b>false</b><br><br>

</dd>
<dt><big><a name="BigInt.clear"></a>void <u>clear</u>();
</big></dt>
<dd>Zeroize the BigInt. The size of the underlying register is not
 modified.<br><br>

</dd>
<dt><big><a name="BigInt.cmp"></a>const int <u>cmp</u>(ref const BigInt <i>other</i>, bool <i>check_signs</i> = true);
</big></dt>
<dd>Compare this to another BigInt
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt <i>other</i></td>
<td>the BigInt value to compare with</td></tr>
<tr><td>bool <i>check_signs</i></td>
<td>include sign in comparison?</td></tr>
</table><br>
<b>Returns:</b><br>
if (this<n) return -1, if (this>n) return 1, if both
 values are identical return 0 [like Perl's &lt;=&gt; operator]<br><br>

</dd>
<dt><big><a name="BigInt.isEven"></a>const bool <u>isEven</u>();
</big></dt>
<dd>Test if the integer has an even value
<br><br>
<b>Returns:</b><br>
<b>true</b> if the integer is even, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="BigInt.isOdd"></a>const bool <u>isOdd</u>();
</big></dt>
<dd>Test if the integer has an odd value
<br><br>
<b>Returns:</b><br>
<b>true</b> if the integer is odd, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="BigInt.isNonzero"></a>const bool <u>isNonzero</u>();
</big></dt>
<dd>Test if the integer is not zero
<br><br>
<b>Returns:</b><br>
<b>true</b> if the integer is non-zero, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="BigInt.isZero"></a>const bool <u>isZero</u>();
</big></dt>
<dd>Test if the integer is zero
<br><br>
<b>Returns:</b><br>
<b>true</b> if the integer is zero, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="BigInt.setBit"></a>void <u>setBit</u>(size_t <i>n</i>);
</big></dt>
<dd>Set bit at specified position
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>bit position to set</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.clearBit"></a>void <u>clearBit</u>(size_t <i>n</i>);
</big></dt>
<dd>Clear bit at specified position
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>bit position to clear</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.maskBits"></a>void <u>maskBits</u>(size_t <i>n</i>);
</big></dt>
<dd>Clear all but the lowest <i>n</i> bits
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>amount of bits to keep</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.getBit"></a>const bool <u>getBit</u>(size_t <i>n</i>);
</big></dt>
<dd>Return bit value at specified position
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>the bit offset to test</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b>, if the bit at position <i>n</i> is set, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="BigInt.getSubstring"></a>const uint <u>getSubstring</u>(size_t <i>offset</i>, size_t <i>length</i>);
</big></dt>
<dd>Return (a maximum of) 32 bits of the complete value
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>offset</i></td>
<td>the <i>offset</i> to start extracting</td></tr>
<tr><td>size_t <i>length</i></td>
<td>amount of bits to extract (starting at <i>offset</i>)</td></tr>
</table><br>
<b>Returns:</b><br>
the integer extracted from the register starting at
 <i>offset</i> with specified <i>length</i><br><br>

</dd>
<dt><big><a name="BigInt.toUint"></a>const uint <u>toUint</u>();
</big></dt>
<dd>Convert this value into a uint, if it is in the range
 [0 ... 2**32-1], or otherwise throw new an exception.
<br><br>
<b>Returns:</b><br>
the value as a uint if conversion is possible<br><br>

</dd>
<dt><big><a name="BigInt.byteAt"></a>const ubyte <u>byteAt</u>(size_t <i>n</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>the offset to get a ubyte from</td></tr>
</table><br>
<b>Returns:</b><br>
ubyte at offset <i>n</i><br><br>

</dd>
<dt><big><a name="BigInt.wordAt"></a>const word <u>wordAt</u>(size_t <i>n</i>);
</big></dt>
<dd>Return the word at a specified position of the internal register
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>position in the register</td></tr>
</table><br>
<b>Returns:</b><br>
value at position <i>n</i><br><br>

</dd>
<dt><big><a name="BigInt.isNegative"></a>const bool <u>isNegative</u>();
</big></dt>
<dd>Tests if the sign of the integer is negative
<br><br>
<b>Returns:</b><br>
<b>true</b>, iff the integer has a negative sign<br><br>

</dd>
<dt><big><a name="BigInt.isPositive"></a>const bool <u>isPositive</u>();
</big></dt>
<dd>Tests if the sign of the integer is positive
<br><br>
<b>Returns:</b><br>
<b>true</b>, iff the integer has a positive sign<br><br>

</dd>
<dt><big><a name="BigInt.sign"></a>const Sign <u>sign</u>();
</big></dt>
<dd>Return the <u>sign</u> of the integer
<br><br>
<b>Returns:</b><br>
the <u>sign</u> of the integer<br><br>

</dd>
<dt><big><a name="BigInt.reverseSign"></a>const Sign <u>reverseSign</u>();
</big></dt>
<dd><b>Returns:</b><br>
the opposite sign of the represented integer value<br><br>

</dd>
<dt><big><a name="BigInt.flipSign"></a>void <u>flipSign</u>();
</big></dt>
<dd>Flip the sign of this BigInt<br><br>

</dd>
<dt><big><a name="BigInt.setSign"></a>void <u>setSign</u>(Sign <i>s</i>);
</big></dt>
<dd>Set sign of the integer
<br><br>
<b>Params:</b><br>
<table><tr><td>Sign <i>s</i></td>
<td>new Sign to set</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.abs"></a>const BigInt <u>abs</u>();
</big></dt>
<dd><b>Returns:</b><br>
absolute (positive) value of this<br><br>

</dd>
<dt><big><a name="BigInt.size"></a>const size_t <u>size</u>();
</big></dt>
<dd>Give <u>size</u> of internal register
<br><br>
<b>Returns:</b><br>
<u>size</u> of internal register in words<br><br>

</dd>
<dt><big><a name="BigInt.sigWords"></a>const size_t <u>sigWords</u>();
</big></dt>
<dd>Return how many words we need to hold this value
<br><br>
<b>Returns:</b><br>
significant words of the represented integer value<br><br>

</dd>
<dt><big><a name="BigInt.bytes"></a>const size_t <u>bytes</u>();
</big></dt>
<dd>Give ubyte length of the integer
<br><br>
<b>Returns:</b><br>
ubyte length of the represented integer value<br><br>

</dd>
<dt><big><a name="BigInt.bits"></a>const size_t <u>bits</u>();
</big></dt>
<dd>Get the bit length of the integer
<br><br>
<b>Returns:</b><br>
bit length of the represented integer value<br><br>

</dd>
<dt><big><a name="BigInt.mutablePtr"></a>word* <u>mutablePtr</u>();
</big></dt>
<dd>Return a mutable pointer to the register
<br><br>
<b>Returns:</b><br>
a pointer to the start of the internal register<br><br>

</dd>
<dt><big><a name="BigInt.ptr"></a>const @property const(word*) <u>ptr</u>();
</big></dt>
<dd>Return a const pointer to the register
<br><br>
<b>Returns:</b><br>
a pointer to the start of the internal register<br><br>

</dd>
<dt><big><a name="BigInt.growTo"></a>void <u>growTo</u>(size_t <i>n</i>);
</big></dt>
<dd>Increase internal register buffer to at least <i>n</i> words
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>new size of register</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.randomize"></a>void <u>randomize</u>(RandomNumberGenerator <i>rng</i>, size_t <i>bitsize</i> = 0);
</big></dt>
<dd>Fill BigInt with a random number with size of <i>bitsize</i>
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>the random number generator to use</td></tr>
<tr><td>size_t <i>bitsize</i></td>
<td>number of bits the created random value should have</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.binaryEncode"></a>const void <u>binaryEncode</u>(ubyte* <i>output</i>);
</big></dt>
<dd>Store BigInt-value in a given ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* <i>output</i></td>
<td>destination ubyte array for the integer value</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.binaryDecode"></a>void <u>binaryDecode</u>(const(ubyte)* <i>buf</i>, size_t <i>length</i>);
</big></dt>
<dd>Read integer value from a ubyte array with given size
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>buf</i></td>
<td>ubyte array buffer containing the integer</td></tr>
<tr><td>size_t <i>length</i></td>
<td>size of <i>buf</i></td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.binaryDecode.2"></a>void <u>binaryDecode</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>buf</i>);
<br>void <u>binaryDecode</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>buf</i>);
</big></dt>
<dd>Read integer value from a ubyte array (SecureVector!ubyte)
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) buf</td>
<td>the array to load from</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.encodedSize"></a>const size_t <u>encodedSize</u>(Base <i>base</i> = Binary);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>Base <i>base</i></td>
<td>the <i>base</i> to measure the size for</td></tr>
</table><br>
<b>Returns:</b><br>
size of this integer in <i>base</i> <i>base</i><br><br>

</dd>
<dt><big><a name="BigInt.randomInteger"></a>BigInt <u>randomInteger</u>()(RandomNumberGenerator <i>rng</i>, auto ref const BigInt <i>min</i>, auto ref const BigInt <i>max</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>RandomNumberGenerator rng</td>
<td>a random number generator</td></tr>
<tr><td>BigInt min</td>
<td>the minimum value</td></tr>
<tr><td>BigInt max</td>
<td>the maximum value</td></tr>
</table><br>
<b>Returns:</b><br>
random integer in [min,max)<br><br>

</dd>
<dt><big><a name="BigInt.powerOf2"></a>static BigInt <u>powerOf2</u>(size_t <i>n</i>);
</big></dt>
<dd>Create a power of two
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>n</i></td>
<td>the power of two to create</td></tr>
</table><br>
<b>Returns:</b><br>
bigint representing 2^<i>n</i><br><br>

</dd>
<dt><big><a name="BigInt.encode"></a>Vector!ubyte <u>encode</u>()(auto ref const BigInt <i>n</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Encode the integer value from a BigInt to an Array of bytes
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>the BigInt to use as integer source</td></tr>
<tr><td>Base base</td>
<td>number-base of resulting ubyte array representation</td></tr>
</table><br>
<b>Returns:</b><br>
SecureVector of bytes containing the integer with given base<br><br>

</dd>
<dt><big><a name="BigInt.encodeLocked"></a>SecureVector!ubyte <u>encodeLocked</u>()(auto ref const BigInt <i>n</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Encode the integer value from a BigInt to a Secure Array of bytes
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>the BigInt to use as integer source</td></tr>
<tr><td>Base base</td>
<td>number-base of resulting ubyte array representation</td></tr>
</table><br>
<b>Returns:</b><br>
SecureVector of bytes containing the integer with given base<br><br>

</dd>
<dt><big><a name="BigInt.encode.2"></a>void <u>encode</u>()(ubyte* <i>output</i>, auto ref const BigInt <i>n</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Encode the integer value from a BigInt to a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte* output</td>
<td>destination ubyte array for the encoded integer
 value with given base</td></tr>
<tr><td>BigInt n</td>
<td>the BigInt to use as integer source</td></tr>
<tr><td>Base base</td>
<td>number-base of resulting ubyte array representation</td></tr>
</table><br>

</dd>
<dt><big><a name="BigInt.decode"></a>static BigInt <u>decode</u>(const(ubyte)* <i>buf</i>, size_t <i>length</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Create a BigInt from an integer in a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>buf</i></td>
<td>the binary value to load</td></tr>
<tr><td>size_t <i>length</i></td>
<td>size of <i>buf</i></td></tr>
<tr><td>Base <i>base</i></td>
<td>number-<i>base</i> of the integer in <i>buf</i></td></tr>
</table><br>
<b>Returns:</b><br>
BigInt representing the integer in the ubyte array<br><br>

</dd>
<dt><big><a name="BigInt.decode.2"></a>BigInt <u>decode</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>buf</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Create a BigInt from an integer in a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) buf</td>
<td>the binary value to load</td></tr>
<tr><td>Base base</td>
<td>number-base of the integer in buf</td></tr>
</table><br>
<b>Returns:</b><br>
BigInt representing the integer in the ubyte array<br><br>

</dd>
<dt><big><a name="BigInt.decode.3"></a>BigInt <u>decode</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>buf</i>, Base <i>base</i> = Binary);
</big></dt>
<dd>Create a BigInt from an integer in a ubyte array
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) buf</td>
<td>the binary value to load</td></tr>
<tr><td>Base base</td>
<td>number-base of the integer in buf</td></tr>
</table><br>
<b>Returns:</b><br>
BigInt representing the integer in the ubyte array<br><br>

</dd>
<dt><big><a name="BigInt.encode1363"></a>SecureVector!ubyte <u>encode1363</u>()(auto ref const BigInt <i>n</i>, size_t <i>bytes</i>);
</big></dt>
<dd>Encode a BigInt to a ubyte array according to IEEE 1363
<br><br>
<b>Params:</b><br>
<table><tr><td>BigInt n</td>
<td>the BigInt to encode</td></tr>
<tr><td>size_t bytes</td>
<td>the length of the resulting SecureVector!ubyte</td></tr>
</table><br>
<b>Returns:</b><br>
a SecureVector!ubyte containing the encoded BigInt<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2008,2012 Jack Lloyd
 (C) 2014-2015 Etienne Cimon
    2007 FlexSecure

</small>
        </body></html>
