<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>botan.pubkey.pubkey</title>
        </head><body>
        <h1>botan.pubkey.pubkey</h1>
        <!-- Generated by Ddoc from source/botan/pubkey/pubkey.d -->
Public Key Interface
<br><br>
<b>License:</b><br>
Botan is released under the Simplified BSD License (see LICENSE.md)<br><br>

<dl><dt><big><a name="PKEncryptor"></a>interface <u>PKEncryptor</u>;
</big></dt>
<dd>Public Key Encryptor<br><br>

<dl><dt><big><a name="PKEncryptor.encrypt"></a>final const Vector!ubyte <u>encrypt</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>, RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Encrypt a message.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the message as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
<tr><td>RandomNumberGenerator <i>rng</i></td>
<td>the random number source to use</td></tr>
</table><br>
<b>Returns:</b><br>
encrypted message<br><br>

</dd>
<dt><big><a name="PKEncryptor.encrypt.2"></a>final const Vector!ubyte <u>encrypt</u>(Alloc)(ref const Vector!(ubyte, Alloc) <i>input</i>, RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Encrypt a message.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) input</td>
<td>the message</td></tr>
<tr><td>RandomNumberGenerator rng</td>
<td>the random number source to use</td></tr>
</table><br>
<b>Returns:</b><br>
encrypted message<br><br>

</dd>
<dt><big><a name="PKEncryptor.maximumInputSize"></a>abstract const size_t <u>maximumInputSize</u>();
</big></dt>
<dd>Return the maximum allowed message size in bytes.
<br><br>
<b>Returns:</b><br>
maximum message size in bytes<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKDecryptor"></a>interface <u>PKDecryptor</u>;
</big></dt>
<dd>Public Key Decryptor<br><br>

<dl><dt><big><a name="PKDecryptor.decrypt"></a>final const SecureVector!ubyte <u>decrypt</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Decrypt a ciphertext.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the ciphertext as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
</table><br>
<b>Returns:</b><br>
decrypted message<br><br>

</dd>
<dt><big><a name="PKDecryptor.decrypt.2"></a>final const SecureVector!ubyte <u>decrypt</u>(Alloc)(auto ref const Vector!(ubyte, Alloc) <i>input</i>);
</big></dt>
<dd>Decrypt a ciphertext.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) input</td>
<td>the ciphertext</td></tr>
</table><br>
<b>Returns:</b><br>
decrypted message<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKSigner"></a>struct <u>PKSigner</u>;
</big></dt>
<dd>Public Key Signer. Use the signMessage() functions for small
 messages. Use multiple calls update() to process large messages and
 generate the signature by finally calling signature().<br><br>

<dl><dt><big><a name="PKSigner.signMessage"></a>Vector!ubyte <u>signMessage</u>(const(ubyte)* <i>msg</i>, size_t <i>length</i>, RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Sign a message.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>msg</i></td>
<td>the message to sign as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
<tr><td>RandomNumberGenerator <i>rng</i></td>
<td>the <i>rng</i> to use</td></tr>
</table><br>
<b>Returns:</b><br>
signature<br><br>

</dd>
<dt><big><a name="PKSigner.signMessage.2"></a>Vector!ubyte <u>signMessage</u>(ALLOC)(auto ref const Vector!(ubyte, ALLOC) <i>input</i>, RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Sign a message.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, ALLOC) input</td>
<td>the message to sign</td></tr>
<tr><td>RandomNumberGenerator rng</td>
<td>the rng to use</td></tr>
</table><br>
<b>Returns:</b><br>
signature<br><br>

</dd>
<dt><big><a name="PKSigner.update"></a>void <u>update</u>(ubyte <i>input</i>);
</big></dt>
<dd>Add a message part (single ubyte).
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>input</i></td>
<td>the ubyte to add</td></tr>
</table><br>

</dd>
<dt><big><a name="PKSigner.update.2"></a>void <u>update</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Add a message part.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the message part to add as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
</table><br>

</dd>
<dt><big><a name="PKSigner.update.3"></a>void <u>update</u>(ALLOC)(auto ref const RefCounted!(Vector!(ubyte, ALLOC), ALLOC) <i>input</i>);
</big></dt>
<dd>Add a message part.
<br><br>
<b>Params:</b><br>
<table><tr><td>RefCounted!(Vector!(ubyte, ALLOC), ALLOC) input</td>
<td>the message part to add</td></tr>
</table><br>

</dd>
<dt><big><a name="PKSigner.signature"></a>Vector!ubyte <u>signature</u>(RandomNumberGenerator <i>rng</i>);
</big></dt>
<dd>Get the <u>signature</u> of the so far processed message (provided by the
 calls to update()).
<br><br>
<b>Params:</b><br>
<table><tr><td>RandomNumberGenerator <i>rng</i></td>
<td>the <i>rng</i> to use</td></tr>
</table><br>
<b>Returns:</b><br>
<u>signature</u> of the total message<br><br>

</dd>
<dt><big><a name="PKSigner.setOutputFormat"></a>void <u>setOutputFormat</u>(SignatureFormat <i>format</i>);
</big></dt>
<dd>Set the output <i>format</i> of the signature.
<br><br>
<b>Params:</b><br>
<table><tr><td>SignatureFormat <i>format</i></td>
<td>the signature <i>format</i> to use</td></tr>
</table><br>

</dd>
<dt><big><a name="PKSigner.this"></a>this(in PrivateKey <i>key</i>, in string <i>emsa_name</i>, SignatureFormat <i>format</i> = IEEE_1363, FaultProtection <i>prot</i> = ENABLE_FAULT_PROTECTION);
</big></dt>
<dd>Construct a PK Signer.
<br><br>
<b>Params:</b><br>
<table><tr><td>PrivateKey <i>key</i></td>
<td>the <i>key</i> to use inside this signer</td></tr>
<tr><td>string <i>emsa_name</i></td>
<td>the EMSA to use, e.g. "EMSA1(SHA-224)".</td></tr>
<tr><td>SignatureFormat <i>format</i></td>
<td>the signature <i>format</i> to use</td></tr>
<tr><td>FaultProtection <i>prot</i></td>
<td>says if fault protection should be enabled</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKVerifier"></a>struct <u>PKVerifier</u>;
</big></dt>
<dd>Public Key Verifier. Use the verifyMessage() functions for small
 messages. Use multiple calls update() to process large messages and
 verify the signature by finally calling checkSignature().<br><br>

<dl><dt><big><a name="PKVerifier.verifyMessage"></a>bool <u>verifyMessage</u>(const(ubyte)* <i>msg</i>, size_t <i>msg_length</i>, const(ubyte)* <i>sig</i>, size_t <i>sig_length</i>);
</big></dt>
<dd>Verify a signature.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>msg</i></td>
<td>the message that the signature belongs to, as a ubyte array</td></tr>
<tr><td>size_t <i>msg_length</i></td>
<td>the length of the above ubyte array <i>msg</i></td></tr>
<tr><td>const(ubyte)* <i>sig</i></td>
<td>the signature as a ubyte array</td></tr>
<tr><td>size_t <i>sig_length</i></td>
<td>the length of the above ubyte array <i>sig</i></td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the signature is valid<br><br>

</dd>
<dt><big><a name="PKVerifier.verifyMessage.2"></a>bool <u>verifyMessage</u>(Alloc, Alloc2)(auto ref const Vector!(ubyte, Alloc) <i>msg</i>, auto ref const Vector!(ubyte, Alloc2) <i>sig</i>);
<br>bool <u>verifyMessage</u>(Alloc, Alloc2)(auto ref const RefCounted!(Vector!(ubyte, Alloc), Alloc) <i>msg</i>, auto ref const RefCounted!(Vector!(ubyte, Alloc2), Alloc2) <i>sig</i>);
</big></dt>
<dd>Verify a signature.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) msg</td>
<td>the message that the signature belongs to</td></tr>
<tr><td>Vector!(ubyte, Alloc2) sig</td>
<td>the signature</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the signature is valid<br><br>

</dd>
<dt><big><a name="PKVerifier.update"></a>void <u>update</u>(ubyte <i>input</i>);
</big></dt>
<dd>Add a message part (single ubyte) of the message corresponding to the
 signature to be verified.
<br><br>
<b>Params:</b><br>
<table><tr><td>ubyte <i>input</i></td>
<td>the ubyte to add</td></tr>
</table><br>

</dd>
<dt><big><a name="PKVerifier.update.2"></a>void <u>update</u>(const(ubyte)* <i>input</i>, size_t <i>length</i>);
</big></dt>
<dd>Add a message part of the message corresponding to the
 signature to be verified.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>input</i></td>
<td>the new message part as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
</table><br>

</dd>
<dt><big><a name="PKVerifier.update.3"></a>void <u>update</u>(ref const Vector!ubyte <i>input</i>);
</big></dt>
<dd>Add a message part of the message corresponding to the
 signature to be verified.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!ubyte <i>input</i></td>
<td>the new message part</td></tr>
</table><br>

</dd>
<dt><big><a name="PKVerifier.checkSignature"></a>bool <u>checkSignature</u>(const(ubyte)* <i>sig</i>, size_t <i>length</i>);
</big></dt>
<dd>Check the signature of the buffered message, i.e. the one build
 by successive calls to update.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(ubyte)* <i>sig</i></td>
<td>the signature to be verified as a ubyte array</td></tr>
<tr><td>size_t <i>length</i></td>
<td>the <i>length</i> of the above ubyte array</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the signature is valid, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="PKVerifier.checkSignature.2"></a>bool <u>checkSignature</u>(Alloc)(auto ref const Vector!(ubyte, Alloc) <i>sig</i>);
</big></dt>
<dd>Check the signature of the buffered message, i.e. the one build
 by successive calls to update.
<br><br>
<b>Params:</b><br>
<table><tr><td>Vector!(ubyte, Alloc) sig</td>
<td>the signature to be verified</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the signature is valid, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="PKVerifier.setInputFormat"></a>void <u>setInputFormat</u>(SignatureFormat <i>format</i>);
</big></dt>
<dd>Set the <i>format</i> of the signatures fed to this verifier.
<br><br>
<b>Params:</b><br>
<table><tr><td>SignatureFormat <i>format</i></td>
<td>the signature <i>format</i> to use</td></tr>
</table><br>

</dd>
<dt><big><a name="PKVerifier.this"></a>this(in PublicKey <i>key</i>, in string <i>emsa_name</i>, SignatureFormat <i>format</i> = IEEE_1363);
</big></dt>
<dd>Construct a PK Verifier.
<br><br>
<b>Params:</b><br>
<table><tr><td>PublicKey <i>key</i></td>
<td>the public <i>key</i> to verify against</td></tr>
<tr><td>string <i>emsa_name</i></td>
<td>the EMSA to use (eg "EMSA3(SHA-1)")</td></tr>
<tr><td>SignatureFormat <i>format</i></td>
<td>the signature <i>format</i> to use</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKKeyAgreement"></a>class <u>PKKeyAgreement</u>;
</big></dt>
<dd>Key used for key agreement<br><br>

<dl><dt><big><a name="PKKeyAgreement.this"></a>this(in PKKeyAgreementKey <i>key</i>, in string <i>kdf_name</i>);
</big></dt>
<dd>Construct a PK Key Agreement.
<br><br>
<b>Params:</b><br>
<table><tr><td>PKKeyAgreementKey <i>key</i></td>
<td>the <i>key</i> to use</td></tr>
<tr><td>string <i>kdf_name</i></td>
<td>name of the KDF to use (or 'Raw' for no KDF)</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKEncryptorEME"></a>class <u>PKEncryptorEME</u>: <u>botan.pubkey.pubkey.PKEncryptor</u>;
</big></dt>
<dd>Encryption with an MR algorithm and an EME.<br><br>

<dl><dt><big><a name="PKEncryptorEME.this"></a>this(in PublicKey <i>key</i>, in string <i>eme_name</i>);
</big></dt>
<dd>Construct an instance.
<br><br>
<b>Params:</b><br>
<table><tr><td>PublicKey <i>key</i></td>
<td>the <i>key</i> to use inside the decryptor</td></tr>
<tr><td>string <i>eme_name</i></td>
<td>the EME to use</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="PKDecryptorEME"></a>class <u>PKDecryptorEME</u>: <u>botan.pubkey.pubkey.PKDecryptor</u>;
</big></dt>
<dd>Decryption with an MR algorithm and an EME.<br><br>

<dl><dt><big><a name="PKDecryptorEME.this"></a>this(in PrivateKey <i>key</i>, in string <i>eme_name</i>);
</big></dt>
<dd>Construct an instance.
<br><br>
<b>Params:</b><br>
<table><tr><td>PrivateKey <i>key</i></td>
<td>the <i>key</i> to use inside the encryptor</td></tr>
<tr><td>string <i>eme_name</i></td>
<td>the EME to use</td></tr>
</table><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (C) 1999-2010 Jack Lloyd
 (C) 2014-2015 Etienne Cimon

</small>
        </body></html>
